[{"title":"Java 环境配置","url":"/2023/02/08/Java-Config/","content":"\nJava 环境配置，主要有 JDK 1.8、Maven 和 Tomcat。\n\n<!-- more -->\n\n## JDK\n\n### 安装\n\n> 注：使用 zip 安装的，jdk exe转换为zip(https://bgasparotto.com/convert-jdk-exe-zip)\n\n### 新建系统变量\n\n变量名：JAVA_HOME\n\n变量值：D:\\Environment\\JDK\\jdk-8 (注：jdk 安装路径)\n\n### 编辑系统变量中的Path\n\n>新增:\n>%JAVA_HOME%\\bin\n>%JAVA_HOME%\\jre\\bin\n\n### 验证\n\n```shell\njava -version\njavac -version\n```\n\n\n\n## Maven\n\n### 下载\n\n地址：https://maven.apache.org/download.cgi\n\n### 配置环境变量\n\n新建系统变量：\n\n\t变量名：Maven_Home\n\t变量值：D:\\Environment\\Maven\\apache-maven-3.8.1\n\n编辑系统变量中的Path\n\n\t新增：%Maven_Home%\\bin\n\n注：验证是否配置成功 `mvn -v`\n\n### 配置本地仓库\n\n1、在安装目录的同级目录下新建一个文件夹 maven-repo(`文件名随意`)，如下\n\n```shell\n.\n├── apache-maven-3.8.1\n└── maven-repo\n```\n\n2、修改配置为本地仓库地址，增加如图所示一行（配置文件在conf下）\n\n![image-20230209221614209](Java-Config/image-20230209221614209.png)\n\n```xml\n<localRepository>D:\\Environment\\Maven\\maven-repo</localRepository>\n```\n\n\n\n### 修改源\n\n在setting.xml文件中，找到 <misrrors> 标签，修改如下，以`阿里云仓库`为例\n\n```xml\n<mirrors>\n    <mirror>\n      <id>nexus-aliyun</id>\n      <mirrorOf>central</mirrorOf>\n      <name>Nexus aliyun</name>\n      <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n\t</mirror>\n    <mirror>\n      <id>maven-default-http-blocker</id>\n      <mirrorOf>external:http:*</mirrorOf>\n      <name>Pseudo repository to mirror external repositories initially using HTTP.</name>\n      <url>http://0.0.0.0/</url>\n      <blocked>true</blocked>\n    </mirror>  \n</mirrors>\n```\n\n\n\n## Tomcat\n\n### 下载\n\n地址：https://tomcat.apache.org/download-10.cgi\n\n### 配置环境变量\n\n新建系统变量\n\n```\n变量名：CATALINA_HOME\n变量值：D:\\Environment\\Tomact\\apache-tomcat-9.0.52\n\n变量名：CLASSPATH\n变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n```\n\n编辑系统变量中Path\n\n```\n%CATALINA_HOME%\\lib\n%CATALINA_HOME%\\bin\n```\n\n","tags":["Java"],"categories":["Java"]},{"title":"nvm 安装与配置","url":"/2023/02/08/nvm/","content":"\nnvm 全名node.js version management，是一个nodejs 的版本管理工具。\n\n<!-- more -->\n\n#### 安装\n\n>GitHub : https://github.com/coreybutler/nvm-windows/releases\n\n#### nvm 换源(淘宝)\n\n```shell\nnode_mirror: https://npm.taobao.org/mirrors/node/\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\n```\n\n#### nvm 常用命令\n\n```shell\n#查看安装的所有node的版本\nnvm list\n\n#查看当前可安装的版本\nnvm list available\n\n#安装xx.xx.xx版本的node\nnvm install 14.16.0\n\n#使用（切换到）xx.xx.xx版本的node\nnvm use 14.16.0\n\n#卸载xx.xx.xx版本的node\nnvm uninstall 14.16.0\n\n#显示node是运行在32位还是64位。\nnvm arch\n\n#设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。\nnvm proxy [url]\n\n#设置node镜像。默认是https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。\nnvm node_mirror [url]\n\n#设置npm镜像。https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。\nnvm npm_mirror [url]\n\n#设置存储不同版本node的目录。如果未设置，默认使用当前目录。\nnvm root [path]\n```\n\n#### 例子\n\n```shell\n#安装 node 14.16.0\nnvm install 14.16.0\nnvm use 14.16.0\nnpm -v\n```\n\n","tags":["nvm"],"categories":["nvm"]},{"title":"Git 安装与配置","url":"/2023/02/08/Git-Config/","content":"\ngit 安装与配置\n\n<!-- more -->\n\n#### 安装 git 软件\n\n> 地址：https://git-scm.com/download/win\n\n#### 配置全局用户名和邮箱\n\n```shell\ngit config --global user.name \"xxx\"\ngit config --global user.email \"xxx\"\n```\n\n#### 配置 `ssh` 免密登录\n\n```shell\n#创建文件夹 (如果不存在的话)\nmkdir ~/.ssh\n#切换到 ssh 文件夹下\ncd ~/.ssh\n#生成 一直默认\nssh-keygen -t rsa -C \"邮箱\"\n#复制~/.ssh/ 路径下的id_rsa.pub文件中的全部内容（去github、gitee）\n```\n","tags":["git"],"categories":["git"]},{"title":"Git-命令","url":"/2022/04/17/Git-命令/","content":"\n git 常用命令\n\n<!-- more -->\n\n基本命令\n---\n\n- `git init` 初始化\n- `git add` 把文件添加到仓库中\n- `git commit` 把文件提交到仓库中\n  - `-m` 添加本次体提交说明\n\n- `git status` 查看当前仓库状态\n\n- `git diff` 查看文件修改内容\n- `git log` 查看提交日志\n- `git reset --hard commit_id` 版本回退\n- `git reflog` 查看历史命令\n- `git remote add origin ` 添加远程仓库\n\n### git branch 创建分支\n\n```shell\ngit branch branchname \t\t\t#创建新分支\ngit branch | git branch --list  #列出所有分支\ngit branch -a \t\t\t\t\t#列出所有分支\ngit branch -f \t\t\t\t\t#列出本地分支\ngit branch -r \t\t\t\t\t#列出远程分支\n```\n\n\n\n### git checkout\n\n```shell\ngit checkout bugFix \t\t\t#切换到 bugFix 分支上\ngit checkout -b bugFix\t\t\t#创建 bugFix 分支并切换到 bugFix 上\n```\n\n\n\n### git fetch \n\n```shell\ngit fetch \n```\n\n### git merge\n\n```shell\ngit merge\n```\n\n### git rebase\n\n```shell\ngit rebase\n```\n\n\n\n### git pull\n\n```shell\n#强制远程拉取并覆盖本地\ngit fetch --all\ngit reset --hard origin/master\ngit pull\n```\n\n### git push\n\n```shell\ngit push -f origin master #强制推送\n```\n\n","tags":["git"],"categories":["git"]},{"title":"Linux 一些功能","url":"/2022/04/17/Linux/","content":"\nLinux 一些功能\n\n<!-- more -->\n\ncrontab 定时任务\n---\n\n1.编辑定时任务\n\n```shell\ncrontab -e\n```\n\n![image-20220417003236733](Linux/image-20220417003236733.png)\n\n> 第一次会弹出编辑器选择，建议选择 /usr/bin/vim.basic 编辑器，选错了可以使用 select-editor 重新选择\n\ncron 表达式不会可以去 [crontab guru](https://crontab.guru/) 网站\n\n格式：\n\n```shell\n0 7 * * *  python3 index.py >> /tmp/test.txt\ncron 表达式 运行的指令 日志保存地址\n```\n\n2.查看定时任务\n\n```shell\ncront\n```\n\n\n\n","tags":["linux"],"categories":["linux"]},{"title":"项目部署笔记","url":"/2021/11/14/项目部署笔记/","content":"\n项目部署笔记\n\n<!-- more -->\n\n部署前提\n---\n\n- 项目: 使用的时 springboot 框架，打包使用 `mvn` 打包成 `jar` 包\n- github: 项目上传到 github 上\n- 服务器：\n\n如何部署\n---\n\n1. 编写 Dockerfile\n2. 采用 GitHub Action 将代码编译、打包，上传到服务器上。\n\n","tags":["docker","jar"]},{"title":"Java Thread","url":"/2021/11/08/Java-Thread/","content":"\njava 多线程\n\n<!-- more -->\n\n多线程的创建\n---\n\n1. 继承Thread类【不建议】\n   - 继承Thread类\n   - 重写run方法\n\n```java\nclass MyThread extends Thread{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"执行了\");\n    }\n\n}\n\npublic class ThreadDemo01 {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread thread = new MyThread();\n        thread.setName(\"子线程\");\n        thread.start();\n        System.out.println(Thread.currentThread().getName()+\"执行了\");\n    }\n}\n\n//main执行了\n//子线程执行了\n```\n\n\n\n2. 实现Runnable【推荐】\n   - implements Runnable\n   - 重写run方法\n   - 传进Thread()中\n\n```java\npublic class RunnableDemo {\n    public static void main(String[] args) {\n        MyRunnable runnable = new MyRunnable();\n        Thread thread = new Thread(runnable,\"runnable\");\n        thread.start();\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n\nclass MyRunnable implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"执行了\");\n    }\n}\n```\n\n3. 实现Callable\n   - 实现Callable，重写call方法\n   - 创建线程池，Executors.newCachedThreadPool()\n   - submint\n   - shutdown\n\n```java\npublic class CallableDemo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        MyCallable myCallable = new MyCallable();\n        ExecutorService executor = Executors.newCachedThreadPool();\n        Future<Boolean> submit = executor.submit(myCallable);\n        System.out.println(submit.get());\n        executor.shutdown();\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n\nclass MyCallable implements Callable<Boolean> {\n\n    @Override\n    public Boolean call() throws Exception {\n        System.out.println(Thread.currentThread().getName());\n        return true;\n    }\n}\n\n//结果\npool-1-thread-1\ntrue\nmain\n\n```\n\n\n\n静态代理\n---\n\n总的来说：\n\n - **真实对象** 和 **代理对象** 都要实现同一个接口；\n - **代理对象** 要代理 **真实对象**\n\n特点：\n\n - 代理对象能做很多真实对象不能做的事情\n - 真实对象专注完成自己的\n\n \n\n> 通过Runnable实现多线程，就使用了静态代理【new Thread(new MyRunnable))】\n\n\n\n## 线程状态（6个）\n\n1. new 【新建】\n2. running 【可运行】\n3. blocked 【阻塞】\n4. waiting 【等待】\n5. timed waiting 【定时等待】\n6. terminated 【死亡】\n\n> 获取线程状态方法，Thread.getState();\n\n\n\n线程停止的方法\n---\n\n1. 正常停止\n2. 利用标志位停止\n\n\n\n## Tread中的部分方法\n\n- void join() --- 等待终止指定的线程\n\n> 【插队】\n\n```java\npublic class DemoJoin {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new TestJoin());\n        thread.setName(\"插队\");\n        thread.start();\n        for (int i = 0; i <= 5; i++) {\n            System.out.println(Thread.currentThread().getName()+\":\"+i);\n            if(i == 3){\n                thread.join();\n            }\n        }\n    }\n}\n\nclass TestJoin implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i <= 5; i++) {\n            System.out.println(Thread.currentThread().getName()+\":\"+i);\n        }\n    }\n}\n\n//run\nmain:0\nmain:1\nmain:2\nmain:3\n插队:0\n插队:1\n插队:2\n插队:3\n插队:4\n插队:5\nmain:4\nmain:5\n\nProcess finished with exit code 0\n```\n\n\n\n- void join(long millis)  --- 等待指定的线程终止 或 等待经过指定秒数\n\n- Thread.State getState() --- 线程状态\n\n- void stop() --- 停止该线程（已废弃）\n\n- void suspend() --- 暂停这个线程的执行（已废弃）\n\n- void resume() --- 恢复线程（已废弃）\n\n- static void yield() --- 静态方法，交出运行权\n\n> yield---【礼让】\n>\n> 虽然交出了运行资源，但是下个运行**线程**还是要看 **CPU ** 调度\n\n## 线程状态转化\n\nNew　－－－＞　Runnable\n\n- 调用start()方法，进入Runnable，等待cup时间片\n\n- 一个线程不能重复调用start()即，**线程死亡之后不可重复调用**【start方法中有检测线程状态】\n\n  > start()方法源码\n\n  ```java\n  public synchronized void start() {\n      if (threadStatus != 0)\n          throw new IllegalThreadStateException();\n  \n      group.add(this);\n  \n      boolean started = false;\n      try {\n          start0();\n          started = true;\n      } finally {\n          try {\n              if (!started) {\n                  group.threadStartFailed(this);\n              }\n          } catch (Throwable ignore) {\n  \n          }\n      }\n  }\n  ```\n\nblocked\n\n- 试图获得锁，会进入blocked\n\n\n\n守护线程daemon\n---\n\n> - Thread.setDaemon();\n>\n> - 每个程序都有守护线程如**gc**等\n> - jvm不需要等待守护线程的结束，就可以退出了\n\n## 中断线程\n\nvoid interrupt() --- 向线程发送中断请求，线程的中断状态设置为true（默认false）\n\nstatic boolean interrupted()  --- 测试当前线程是否被中断，会将中断状态设置重置为false\n\nboolean isInterrupted() --- 测试线程是否被中断\n\nstatic Thread currentThread() --- 返回当前正在执行的线程Thread对象\n\n\n\n## 进程间的通信方式\n\n1. 锁和同步\n2. 等待/通知机制\n3. 信号量\n4. 管道\n5. 其它方法：\n   - join()\n   - sleep()\n   - ThreadLocal类\n\n\n\n线程池\n---\n\n### 重要的类和接口\n>\n>| 类                          | 用途                                                         |\n>| :-------------------------- | :----------------------------------------------------------- |\n>| ExecutorService             | 真正实现线程池的接口                                         |\n>| ScheduledExecutorService    | 能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。    |\n>| ThreadPoolExecutor          | ExecutorService的默认实现。                                  |\n>| ScheduledThreadPoolExecutor | 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现 |\n\n\n\n> Executor----**接口**\n\n```java\npublic interface Executor {\n    \n    void execute(Runnable command);\n    \n}\n```\n\n\n\n> Executors --- 提供静态工厂方法用于创建各种线程池的**类**\n\n```java\npublic class Executors {\n    //创建固定数量的线程池\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n    \n    public static ExecutorService newWorkStealingPool(int parallelism) {\n        return new ForkJoinPool\n            (parallelism,\n             ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n             null, true);\n    }\n  \n    public static ExecutorService newWorkStealingPool() {\n        return new ForkJoinPool\n            (Runtime.getRuntime().availableProcessors(),\n             ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n             null, true);\n    }\n    //创建固定数量的线程池\n    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n    }\n    //创建一个单线程的线程池\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n    //创建一个单线程的线程池\n    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>(),\n                                    threadFactory));\n    }\n    //创建一个可缓存的线程池\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n    //创建一个可缓存的线程池\n    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>(),\n                                      threadFactory);\n    }\n\n    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {\n        return new DelegatedScheduledExecutorService\n            (new ScheduledThreadPoolExecutor(1));\n    }\n    \n    public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {\n        return new DelegatedScheduledExecutorService\n            (new ScheduledThreadPoolExecutor(1, threadFactory));\n    }\n    \n    ......\n}\n```\n\n\n\n> ExecutorsService --- 线程池定义的**接口**，继承Excutor，用于线程的操作【shutdown】\n\n```java\npublic interface ExecutorService extends Executor {\n\t//关闭\n    void shutdown();\n\n    List<Runnable> shutdownNow();\n\t//判断\n    boolean isShutdown();\n\n    boolean isTerminated();\n\n    boolean awaitTermination(long timeout, TimeUnit unit)  throws InterruptedException;\n\t//提交\n    <T> Future<T> submit(Callable<T> task);\n\n    <T> Future<T> submit(Runnable task, T result);\n\n    Future<?> submit(Runnable task);\n\t\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;\n\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n\n```\n\n### ThreadPoolExecutor \n\n> ThreadPoolExecutor 是ExecutorService的默认实现\n>\n> 构造方法中参数介绍\n>\n> - corePoolSize : 核心池的大小\n> - maximumPoolSize : 线程池最大线程数\n> - keepAliveTime : 表示线程没有任务执行时最多保持多久时间会终止\n> - unit : 参数keepAliveTime的时间单位\n> - workQueue : 一个阻塞队列，用来存储等待执行的任务\n> - threadFactory : 线程工厂，主要用来创建线程；\n> - handler : 表示当拒绝处理任务时的策略\n>   - ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 \n>   - ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 \n>   - ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\n>   - ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 \n\n```java\n//只取了ThreadPoolExecutor的四个构造方法\npublic class ThreadPoolExecutor extends AbstractExecutorService {\n    .....\n\n \tpublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), defaultHandler);\n    }\n    \n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             threadFactory, defaultHandler);\n    }\n \n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              RejectedExecutionHandler handler) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), handler);\n    }\n \t//前三个最终都调用了这个方法\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.acc = System.getSecurityManager() == null ?null : AccessController.getContext();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n    ...\n}\n```\n\n\n\n### 实例创建线程池\n\n> newCachedThreadPool -- 创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程\n\n```java\npublic class PoolDemo {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        for (int i = 0; i < 20; i++) {\n            executorService.execute(()->{\n                System.out.println(Thread.currentThread().getName());\n            });\n        }\n        executorService.shutdown();\n\n    }\n}\n```\n\n> newFixedThreadPool --- 创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待\n\n```java\nclass FixedThreadDemo{\n    public void run(){\n        ExecutorService executorService = Executors.newFixedThreadPool(5);\n        for (int i = 0; i < 30; i++) {\n            executorService.execute(()->{\n                System.out.println(Thread.currentThread().getName());\n            });\n        }\n        executorService.shutdown();\n    }\n}\n```\n\n> newSingleThreadPool -- 创建一个单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行\n\n```java\nclass SingleThreadDemo{\n    public void run(){\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        for (int i = 0; i < 30; i++) {\n            executorService.execute(()->{\n                System.out.println(Thread.currentThread().getName());\n            });\n        }\n        executorService.shutdown();\n    }\n}\n```\n\n\n\n> newScheduledThreadPool -- 创建一个周期性的线程池，支持定时及周期性执行任务\n\n```java\nclass ScheduledThreadDemo{\n    public void run(){\n        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3);\n        System.out.println(\" 提交任务\");\n        for (int i = 0; i < 10; i++) {\n            final int index = i;\n            executorService.schedule(() -> {\n                // 获取线程名称,默认格式:pool-1-thread-1\n                System.out.println(Thread.currentThread().getName() + \" \" + index);\n            }, 3, TimeUnit.SECONDS);\n        }\n        executorService.shutdown();\n    }\n}\n```\n\n\n\n> ThreadPoolExecutor -- 【推荐使用，根据需求创建合适的线程池】\n\n```java\nclass ThreadPoolExecutorDemo{\n    public void run() throws InterruptedException {\n        ExecutorService executorService = new ThreadPoolExecutor(100, 1000,\n                1, TimeUnit.MINUTES, new ArrayBlockingQueue<>(5, true),\n                Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n        for (int i = 0; i < 2000; i++) {\n            executorService.execute(()->{\n                System.out.println(Thread.currentThread().getName());\n            });\n            sleep(2);\n        }\n        executorService.shutdown();\n    }\n}\n```\n\n\n\n重要知识点\n---\n\n### 使用线程池的好处\n\n- **降低资源消耗**：通过池化的技术重复利用被创建的线程，降低线程创建和销毁造成的开销\n- **提高响应速度**：当任务到达时，无需等待线程创建即可立即执行\n- **提高线程的可管理性**：**线程是稀缺资源**，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。**使用线程池可以进行统一的分配、调优和监控**。\n- **提供更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能\n\n\n\n### 线程池解决的核心问题\n\n> 线程池解决的核心问题就是**资源管理问题**\n>\n\n在并法的环境下，系统不确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这样的不去确定性会带来问题：\n\n1. 频繁申请/销毁资源和调度资源，将带来**额外的消耗**，可能会非常巨大。\n2. 对资源无限申请缺少抑制手段，**易引发系统资源耗尽的风险**。\n3. 系统无法合理管理内部的资源分布，会降低**系统的稳定性**。\n\n为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想\n\n\n\n### ThreadPoolExecutor是如何运行\n\n线程池的运行主要分成两部分：任务管理、线程管理。\n\n![img](Java-Thread/ThreadPoolExecutor.png)\n\n\n\n### 生命周期管理\n\n线程池内使用一个变量维护两个变量：**运行状态**(runState)和**线程数量** (workerCount--有效线程数)\n\n线程池有五种状态：\n\n1. RUNNING     -- 能接收新提交的任务，也可以处理阻塞队列的任务\n2. SHUTDOWN    -- 关闭状态，不可以接收新的任务，但是可以继续处理阻塞队列的任务\n3. STOP        -- 不接收新的任务，也不处理阻塞队列中的任务，会中断正在处理任务的线程\n4. TIDYING     -- 所有任务都终止了，workerCount（有效线程数）为 0\n5. TERMINATED   -- 在terminated（）方法之后进入这个状态\n\n\n\n生命周期的转化\n\n![图3 线程池生命周期](Java-Thread/ThreadPool-state.png)\n\n### 任务调度\n\n> 所有任务的调度都是由**execute方法**完成的\n\n执行过程如下：\n\n1. 首先检查线程池的状态，如果不是Running，直接拒绝执行\n2. 如果workerCount < corePoolSize ,则创建并启动一个线程来执行该任务\n3. 如果workerCount >= corePoolSize && 阻塞队列未满，则将该任务放入阻塞队列中\n4. 如果workerCount >= corePoolSize && workerCount < maximumPoolSize ,且阻塞队列已满，则创建并启动一个线程来执行该任务\n5. 如果workerCount >= maximumPoolSize ,并且线程池内的阻塞队列已满，则根据**拒绝策略来处理该任务**, **默认的处理方式是直接抛异常**\n\n### 拒绝策略\n\n当线程数量大于maximumPoolSize，就会执行拒绝策略。ThreadPoolExecutor类中一共有4种拒绝策略。\n\n通过实现**RejectedExecutionHandler**接口。\n\n- AbortPolicy【终止策略】 ： 线程任务丢弃报错。默认饱和策略。\n- DiscardPolicy 【丢弃策略】： 线程任务直接丢弃不报错。\n- DiscardOldestPolicy 【丢弃阻塞队列中的最老策略】： 将workQueue**队首任务丢弃**，将最新线程任务重新加入队列执行。\n- CallerRunsPolicy 【直接调用run方法】：线程池之外的线程直接调用run方法执行。\n","tags":["Thread"],"categories":["Java"]},{"title":"InnoDB Page Formats","url":"/2021/11/07/InnoDB-Page-Formats/","content":"\nInnoDB数据页格式\n\n<!-- more -->\n\n页简介\n---\n\n页（page）是 InnoDB 管理存储空间的基本单位，一页大小一般为 `16KB` \n\n**页类型**\n\n- 数据页（B-Tree Node）\n- Undo页（Undo Log Page）\n- 系统页（System Page）\n- 事务数据页（Transaction System Page）\n- 等等\n\n\n\n数据页结构\n---\n\n一个 InnoDB 数据页的存储空间大概被划分为 7 个部分\n\n<img src=\"InnoDB-Page-Formats/image-20211107214720247.png\" alt=\"image-20211107214720247\" style=\"zoom: 80%;\" />\n\n- Fil Header（38 Bytes）               --头部文部           页的一些通用信息\n- Page Header（56 Bytes）              --页面头部           数据页专有的一些信息\n- Infimum + Supremum Records（26 Bytes）--最小记录和最大记录   两个虚拟的行记录\n- User Records                        --用户记录           实际存储的行记录内容\n- Free Space                          --空闲空间           页中尚未使用的空间\n- Page Directory                      --页面目录           页中的某些记录的相对位置\n- Fil Trailer（8 Bytes）               --文件尾部           校验页是否完整\n\n一个页有两个头/尾对，其中，Fil Header 与 Fil Trailer 为一对，Page Header 与 Page Directory 为另一对。前者用于定义文件，为 fil 相关程序组所关心；后者用于定义页，为 page 相关程序组所关心。\n\n> Fil 即 File\n\n夹在头尾中间的部分，即记录（records）和空闲空间（free space）。一个页面总是以两个不变的记录 Infimum 和 Supremum 开始，接下来是用户记录。在**向下增长**的用户空间与**向上增长**的 Page Directory 之间，是提供给新记录的空间空间。\n\n> 新创建的页面是不存在 User Records（用户记录）的，当插入第一条数据时，会从 Free Space 申请空间，才会出现这个部分。当 Free Space 被用完时，新插入的记录会放在新申请的数据页中。\n\n\n\n## ibd 文件\n\nWindows 下表空间数据存储在 *C:\\ProgramData\\MySQL\\MySQL Server 5.7\\Data\\\\[数据库名]\\\\[表名].ibd* 中。\n\n借助 Visual Studio Code 的 hexdump 扩展，查看该文件。\n\n当前表中数据内容如下：\n\n<img src=\"InnoDB-Page-Formats/image-20211107224411619.png\" alt=\"image-20211107224411619\" style=\"zoom:80%;\" />\n\n首先查询当前的页大小：\n\n```sql\nmysql> show status like 'Innodb_page_size';\n+------------------+-------+\n| Variable_name    | Value |\n+------------------+-------+\n| Innodb_page_size | 16384 |\n+------------------+-------+\n1 row in set (0.00 sec)\n```\n\n当前的测试环境下 InnoDB 页大小为 16 KB。因此，ibd 文件每 16 KB 属于一个页。\n\n第一个页的范围应当为 `0x0000000` ~ `0x00003ff0`。以此类推，我们把整个文件切分为多个 16 KB 部分。本文不讨论文件格式，因此直接定位到目标页，本次测试环境下是 `0x0000c000` 即第四页为测试数据存储位置。\n\n上图分析：蓝色部分为 38 字节的 Fil Header，黄色为 56 字节的 Page Header，红色为 26 字节的 Infimum + Supremum 记录。\n\n其后一部分就是数据, 绿色划线部分为 8 字节的 Fil Tailer\n\n<img src=\"InnoDB-Page-Formats/image-20211107225400407.png\" alt=\"image-20211107225400407\" style=\"zoom: 80%;\" />\n\n\n\n记录在页中的存储\n---\n\nInooDB 定义了两个伪记录分别维最小记录和最大记录（占 26 字节），都是由 `5` 字节大小的**记录头信息**和 `8` 字节大小的一个固定的部分组成，如下图\n\n<img src=\"InnoDB-Page-Formats/image-20211108124159344.png\" alt=\"image-20211108124159344\" style=\"zoom:80%;\" />\n\n在一开始生成页的时候，其实并没有 User Record 这个部分，每当我们插入一条记录，都会从 Free Space 部分申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分使用完，就要申请新的页。\n\nUser Record 中的**记录按照主键的从小到大的顺序形成一个单链表 **( next_record )\n\n<img src=\"InnoDB-Page-Formats/image-20211107204848266.png\" alt=\"image-20211107204848266\" style=\"zoom: 25%;\" />\n\n> 规定: `Infimum ` 记录的下一条记录就是本页中**主键最小**的用户记录，\n>\n> 本页中主键最大的用户记录(next_record = 0)的下一条记录就是 `Supremum` 记录\n\n不论怎么对页中的记录做增删改查操作，InnoDB **始终会维护一条记录的单链表**。\n\n> 注：当数据页中存在多条被删除的记录时，这些记录的 next_record 属性将会把这些被删除的记录组成一个**垃圾链表**，以备之后重用这个部分存储。\n\nPage Directory\n---\n\n页目录生成过程\n\n- 将所有正常记录（包括最小记录和最大记录，不包括标记删除的记录）划分为几个**组**\n- 每个组的**最后**一条记录（组内最大的那条记录）的头信息中 `n_owned` 属性表示该记录拥有多少条记录，也就是该组内有多少条记录\n- 将每组的最后一条记录的**地址偏移量**（从页面的 0 字节开始数）单独提取出来按**顺序存储到靠近页的尾部**的地方（即 Page Directory）\n\n> 页面目录中的这些**地址偏移量**被称为**槽**(Slot),所以**页目录就是由槽组成**。如下图所示\n\n<img src=\"InnoDB-Page-Formats/image-20211108144451388.png\" alt=\"image-20211108144451388\" style=\"zoom: 80%;\" />\n\n每个分组中记录条数规定:\n\n - 对于**最小记录**所在的分组只能由 `1` 条记录\n - **最大记录**所在分组拥有的记录数只能在 `1~8` 条\n - 剩下的分组记录数只能在 `4~8` 条\n\n\n\n分组步骤：\n\n 1. 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。 \n 2. 之后每插入一条记录，都会从**页目录**中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 `n_owned` 值加 `1`，表示本组内又添加了一条记录，直到该组中的记录数等于 `8` 个。 \n 3. 在一个组中的记录数等于 `8` 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 `4` 条记录，另一 个 `5` 条记录。这个过程会在页目录中新增一个**槽**来记录这个新增分组中最大的那条记录的偏移量。\n\n\n\n数据页中查找**指定主键值**的记录的过程分为两步:\n\n1. 通过**二分法**确定该记录所在的槽，并找到该槽中主键值最小的那条记录。\n2. 通过记录的 `next_record `属性遍历该槽所在的组中的各个记录。\n\nPage Header\n---\n\n> 页面头部：占有固定的 `56` 字节，专门存储各种状态信息，例如存储了多少个槽，多少条记录等等\n\n各个字节的作用如下表：\n\n| 名称              | 占用空间的大小（字节） | 描述                                                         |\n| ----------------- | :--------------------: | ------------------------------------------------------------ |\n| PAGE_N_DIR_SLOTS  |           2            | 在页目录中的槽数量                                           |\n| PAGE_HEAP_TOP     |           2            | 还未使用的空间最小地址，也就是说从该地址之后就是 Free Space  |\n| PAGE_N_HEAP       |           2            | 本页中的记录的数量(包括最小和最大记录以及标记为删除的记录)   |\n| PAGE_FREE         |           2            | 第一个已经标记为删除的记录地址(各个已删除的记录通过 next_record 也会组成一个单链 表，这个单链表中的记录可以被重新利用) |\n| PAGE_GARBAGE      |           2            | 已删除记录占用的字节数                                       |\n| PAGE_LAST_INSERT  |           2            | 最后插入记录的位置                                           |\n| PAGE_DIRECTION    |           2            | 记录插入的方向                                               |\n| PAGE_N_DIRECTION  |           2            | 一个方向连续插入的记录数量                                   |\n| PAGE_N_RECS       |           2            | 该页中记录的数量(不包括最小和最大记录以及被标记为删除的记录) |\n| PAGE_MAX_TRX_ID   |           8            | 修改当前页的最大事务 ID，该值仅在二级索引中定义              |\n| PAGE_LEVEL        |           2            | 当前页在 B+ 树中所处的层级                                   |\n| PAGE_INDEX_ID     |           8            | 索引 ID，表示当前页属于哪个索引                              |\n| PAGE_BTR_SEG_LEAF |           10           | B+ 树叶子段的头部信息，仅在 B+ 树的 Root 页定义              |\n| PAGE_BTR_SEG_TOP  |           10           | B+ 树非叶子段的头部信息，仅在 B+ 树的 Root 页定义            |\n\nFile Header\n---\n\n> 文件头部记录这页面的通用信息，例如页的编码，上一页，下一页等等，占用固定字节 `38`\n\n| 名称                             | 占用空间大小（字节） | 描述                                                         |\n| -------------------------------- | :------------------: | ------------------------------------------------------------ |\n| FIL_PAGE_SPACE_OR_CHKSUM         |          4           | 页的校验和(checksum值)                                       |\n| FIL_PAGE_OFFSET                  |          4           | 页号                                                         |\n| FIL_PAGE_PREV                    |          4           | 上一个页的页号                                               |\n| FIL_PAGE_NEXT                    |          4           | 下一个页的页号                                               |\n| FIL_PAGE_LSN                     |          8           | 页面被最后修改时对应的日志序列位置(英文名是:Log Sequence Number) |\n| FIL_PAGE_TYPE                    |          2           | 该页的类型                                                   |\n| FIL_PAGE_FILE_FLUSH_LSN          |          8           | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |\n| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID |          4           | 页属于哪个表空间                                             |\n\n> 每个数据页中的 File Header 部分上有上一个和下一个页编号，数据页会组成一个**双链表**\n\n`FIL_PAGE_OFFSET `： 每一个页都有一个单独的页号，就跟你的身份证号码一样， InnoDB 通过页号来可以**唯一定位一个页** \n\nFile Trailer\n---\n\n> File Trailer 检测一个页是否完整，由 8 个字节组成\n>\n\n这 8 个字节可以分为两个部分\n\n- 前 4 个字节代表页的校验和\n  - 这个部分适合 File Header 中的校验和相对应。\n- 后 4 个字节代表页面最后被修改时对应的日志序列位置（LSN）\n\n..\n---\n\n- 每个记录的头信息中都有一个 `next_record` 属性，从而使页中的所有记录串联成一个**单链表**\n- 每个数据页中的 File Header 部分上有上一个和下一个页编号，数据页会组成一个**双链表**\n\n","tags":["page formats"],"categories":["Mysql"]},{"title":"InnoDB Row Formats","url":"/2021/11/07/InnoDB-Row-Formats/","content":"\nInnoDB 行格式。 \n\n<!-- more -->\n\n行格式的概念 \n---\n\n**表的行格式**（Row Formats）是指行记录在磁盘上的物理存储方式。行格式会影响查询和 DML 操作的性能，随着单个磁盘页面中容纳更多行，查询（queries）和索引查找（index lookups）可以更快地进行，缓冲池中需要的缓存内存空间会更少，写入更新值所需的 I/O 也更少。 \n\n每个表中的数据被划分为**页**（pages），每个页中有一个或多个行记录。构成每个表的页面排列在称为 B+ 树索引的数据结构中。表数据（聚集索 引）和二级索引都使用这种类型的结构。\n\n\n\n> MySQL 提供了很多长度可变的数据类型，比如 `VARCHAR(M)、 VARBINARY(M)` 以及 `TEXT` 等。这些变长类型的列被称为变长字 段，其中存储的字节大小是不固定的，因此必须通过记录一些额外信息来处理这些变长字段。\n\n\n\n**变长字段**是列值存储在 B+ 树索引节点中的规则的一个例外（即变长字段 内容不一定全在 B+ 树叶子结点中）。太长而不适合 B+ 树页面的可变长度列存储在单独分配的磁盘页面上，称为**溢出页**。此类列称为**页外列**。 页外列的值存储在溢出页面的单向链接列表中，每个这样的列都有自己的 一个或多个溢出页面列表。根据列长度，可变长度列值的全部或前缀存储 在 B+ 树中，以避免浪费存储空间和读取单独的页面。\n\n\n\nInnoDB 支持四种行格式，特性各不相同：\n\n- REDUNDANT \n- COMPACT \n- DYNAMIC \n- COMPRESSED\n\n\n\n|    行格式    | 紧凑的存储特性 | 增强的可变长度列存储 | 大索引键前缀 支持 | 压缩支 持 |        支持的表空间类型         |     所需文件格式      |\n| :----------: | :------------: | :------------------: | :---------------: | :-------: | :-----------------------------: | :-------------------: |\n| `REDUNDANT`  |       No       |          No          |        No         |    No     | system, file-per-table, general | Antelope or Barracuda |\n|  `COMPACT`   |      Yes       |          No          |        No         |    No     | system, file-per-table, general | Antelope or Barracuda |\n|  `DYNAMIC`   |      Yes       |         Yes          |        Yes        |    No     | system, file-per-table, general |       Barracuda       |\n| `COMPRESSED` |      Yes       |         Yes          |        Yes        |    Yes    |     file-per-table, general     |       Barracuda       |\n\n\n\n变量 `innodb_default_row_format `定义了默认使用的格式（默认为 DYNAMIC），而在建表（CREATE）或修改表（ALTER）时，也可以使用 ROW_FORMAT 选项自定义。\n\nCOMPACT\n---\n\nCOMPACT 行格式的结构如下图\n\n<img src=\"InnoDB-Row-Formats/compact-1.png\" />\n\n其中，**变长字段长度列表**、NULL 值列表和记录头信息属于数据之外的额外信息。 \n\n### 变长字段长度列表\n\n**变长字段长度列表**顾名思义，存储的是变长字段的长度，它按照逆序存储 变长列的字节数。例如行中有三列（均为变长类型），从左到右为 c1、 c2、c3，长度分别为 1 字节、2 字节、4字节，那么变长字段长度列表 中存储的就是 0x040201。 \n\n当然这里有一个问题，那就是如果变长字段的长度 1 字节存不下怎么办。 InnoDB 按照一定的规则去处理这些情况。 \n\n对于不同的编码方式，相同字符占用的空间不一定相同，事先约定，某字符集单个字符占用的最大字节数为 MaxLen，例如 UTF-8 编码的 `MaxLen `就是 3 (**这是mysql特有的，真实的utf-8编码长度为1~4字节**)。对于变长类型来说，它们一般是限制字符数量而不是字节数量，因此，VARCHAR(M) 最多能够存储 M 个字符，即 ` M * MaxLen` 个字节。这里假设实际存储的字符串的字节数为 Length。有了 这三个变量，可以设定以下规则。 \n\n- 当 `M * MaxLen = 255`，使用 `1` 字节来存储变长字段长度。\n- 当 `M * MaxLen > 255`，分情况讨论： \n  - `Length = 127`，使用 `1` 字节来存储变长字段长度。 \n  - `Length > 127`，使用 `2 `字节来存储变长字段长度。\n\n#### 特例\n\n1. 变长字段长度列表**不存储值为 NULL 的长度信息**，会在 NULL 的标志位存储；\n2. 变长字段长度列表**不一定能存在**,例如\n   - 表中无变长字段\n   - 变长字段值为 NULL\n3. 变长字段长度列表**各字段的长度信息逆序存储**\n4. char类型字段的长度信息是否需要存储在 变长字段的长度列表 中取决于其所使用的**字符集是否为变长字符集**\n   - MySQL中 `char(M)` 类型的字段表示该字段最多可以存储 **M 个字符**。\n   - 对于定长字符集(如 ascii 字符集)而言，compact 行格式下存储该字段所占有的空间固定为 `M x Maxlen` 个字节。\n   - 但是对于变长字符集而言情况就大不一样了，例如 utf8 字符集，其存储 `M ` 个字符所需的空间为 `M~3M` 个字节。\n   - 在compact行格式下，char类型字段会由于使用变长字符集而导致其所占的**字节数(即长度信息)不定**，故此时 char 类型的数据同样也需要在变长字段的长度列表中存储其长度信息\n\n\n\n\n### NULL值列表\n\n- 二进制位的值为 1 时，代表该列的值为 NULL\n- 二进制位的值为 0 时，代表该列的值不为 NULL\n- MySQL 规定 NULL 值列表必须用整数个字节的位表示\n- 不一定每列都存在 NULL 值标志\n\n\n\n### 记录头信息\n\n![note_info](InnoDB-Row-Formats/note_info.png)\n\n固定为 `5` 个字节\n\n- **预留位1、2**【2 bit】：暂未使用\n- **delete_mask**【1 bit】：当前记录被删除的标志位\n- **min_rec_mask**【1 bit】：B+树的每层非叶子节点中的最小记录的标志位\n- **n_owned**【4 bit】：当前记录拥有的记录数\n- **heap_no**【13 bit】：当前记录在记录堆中的位置\n- **record_type**【3 bit】：当前记录类型。具体地，0: 普通记录；1:  B+ 树非叶子节点记录（即所谓的目录项记录）；2: 最小记录；3: 最大记录\n- **next_record**【16 bit】：下一条记录的相对位置\n\n> next_record 指针指向**记录头信息和真实数据之间的位置**,后面的页格式会用到\n\n### 记录真实数据\n\n1. 隐藏列【19字节】\n\n- **DB_ROW_ID**：该字段占 6 个字节，用于标识一条记录，【不一定存在，只有在用户没有定义主键时，且没有唯一且不为 NULL 的列】\n- **DB_TRX_ID**：该字段占 6 个字节，其值为事务 ID\n- **DB_ROLL_PTR**：该字段占 7 个字节，其值为回滚指针\n\n2. 真实列 1，2，3，4\n\n### 实例分析\n\n#### 建表并插入数据\n\n```sql\nDROP TABLE IF EXISTS `demo1`;\nCREATE TABLE `demo1`  (\n  `test1` varchar(10),\n  `test2` varchar(10),\n  `test3` char(10),\n  `test4` varchar(10)\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;\n\nINSERT INTO `demo1` VALUES ('a', 'bb', 'ccc', 'dddd');\nINSERT INTO `demo1` VALUES ('e', 'ff', NULL, 'hhhh');\nINSERT INTO `demo1` VALUES ('e', NULL, 'ggg', 'hhhh');\n```\n\n#### 找到数据所在位置（ idb 文件）\n\n![compact-analyze](InnoDB-Row-Formats/compact-analyze.png)\n\n#### 分析\n\n只分析第一行数据\n\n**红色的部分** 为 变长字段长度列表，04 0A 02 01 转为十进制是 `4 10 2 1`, 因为是逆序存储, 所以变长字段的长度应该为`1 2 10 4` 正好对应'a'[varchar], 'bb'[varchar], 'ccc'[char(10)], 'dddd'[varchar]，至于为什么定长 char 类型也存在其中（请看特例的第四点）这里不再解释。\n\n**绿色的部分** 为 NULL 值标志位，`00` 代表没有空值\n\n**黄色的部分** 为固定 5 字节大小的记录头信息，`00 00 10 00 2D`\n\n![compact-analyze](InnoDB-Row-Formats/compact-analyze-2.png)\n\n\n\nREDUNDANT\n---\n\n`REDUNDANT` 格式是 MySQL 5.0 之前的版本使用的行记录格式，其后版本提供该格式是为了向后兼容（兼容旧版本）。 \n\n\n\n> REDUNDANT 格式是非常原始的行格式，目前已经很少使用了，其**占用空间最多，内存碎片化最严重，性能较差**。\n\n\n\nREDUNDANT 的格式如下图。\n\n<img src=\"InnoDB-Row-Formats/redundant.png\" alt=\"redundant\"  />\n\n\n\n> ***Redundant*** 是 MySQL 5.0 之前的行结构，于 Compact 的主要区别是字段偏移量长度、 NULL 值列表等\n\n\n\n### 字段长度偏移列表\n\n> 包含了所有列（包括隐藏列）的长度信息，它是首先计算各列的长度信息，然后依次累加，最后逆序存储。\n\n字段长度偏移列表中每个偏移量所占字节要么全是1字节或者 2 字节。\n\n- 当记录数据内容的整个部分数据（包括隐藏列）所占空间小于 `127` 字节,则各偏移量只需要 `1` 个字节\n- 当其所占空间超过 `127` 字节但是小于`32767`字节，则各偏移量需要 `2` 字节\n  - 该记录会通过**记录头信息**的 **1byte_offs_flag** 属性来表明该记录各偏移量的字节数，以便读取记录的时候方便解析\n\n注意：\n\n- 字段长度偏移列表包含 NULL 值标志\n  - 偏移量的第一位实际上是没有使用的，其用于标识该记录下相应列是否为 NULL 值，如果是 NULL 值，则该位为 1；反之，则为 0\n\n### 记录头信息\n\n> 记录头信息用于描述该条记录，其固定为 6 个字节，即 48 位\n\n![note_info2](InnoDB-Row-Formats/note_info2.png)\n\n- **预留位1、2**：暂未使用\n- **delete_mask**【1 bit】：当前记录被删除的标志位\n- **min_rec_mask**【1 bit】：B+ 树的每层非叶子节点中的最小记录的标志位\n- **n_owned**【4 bit】：当前记录拥有的记录数\n- **heap_no**【13 bit】：当前记录在记录堆中的位置\n- **n_field**【10 bit】：表示记录中**列的数量**\n- **1byte_offs_flag**【1 bit】：**标识字段长度偏移列表中各列的偏移量使用的字节数。0：意为每个偏移量均使用 2 个字节表示；1：意为每个偏移量均使用 1 个字节表示**\n- **next_record**【16 bit】：下一条记录的相对位置\n\n\n\n行溢出\n---\n\n众所周知，InnoDB 存储引擎中内存与硬盘交互的基本单位是页，一般地页大小为`16KB`。MySQL 规定一个页中至少需要存放两条记录。\n\n而所谓的**行溢出**是指：当某个记录的某个字段(varchar、text、blob等类型)的值长度过长、数据量过大，会导致一个页中放不下一条记录，为此在compact、redundant行格式中，如果该记录某字段中数据量过多时，则在该记录的数据内容的相应字段处只存储该字段值**前768个字节**的数据和一个指向存储剩余数据的其他页（即所谓的**溢出页**）的**地址**，该地址通常占用**20个字节**\n\n> 通俗的说就是如果数据量过多，数据内容部分只存 **768个前缀字节** 和 **20字节的指针**（指的是 REDUNDANT 和 COMPACT）\n\n  \n\nCOMPRESSED 和 DYNAMIC 行记录格式\n---\n\nInnodb 1.0 之后引入新的文件格式（file format,可以理解为新的页格式）。\n\n> 以前支持 COMPACT 和 REDUNDANT 格式称为 `Antelop` 文件格式，新的文件格式称为`Barracuda`文件格式（包含了两种新的行记录格式：COMPRESSED 和 DYNAMIC)。\n\n新的两种记录格式对于存放 `BLOB ` 中的数据采用了**完全行溢出**方式(数据页中只存放 **20 字节的指针**，实际数据都存放在 `Off Page`)\n\n![off-page](InnoDB-Row-Formats/off-page.png)\n\nCompressed行记录格式的另一个功能，存储在其中的数据会以 `zlib` 的算法进行压缩（对 BLOB、TEXT、VARCHAR 这种特别有用）\n\n\n\n### DYNAMIC\n\n**DYNAMIC**行格式提供了与**COMPACT**行格式相同的存储特性，但为变长字段长度列添加了增强的存储功能，并支持大索引键前缀。\n\n\n\n当使用 ROW_FORMAT=`DYNAMIC`创建表，InnoDB 可以存储`fully off-page`的变长字段长度列值（用于 VARCHAR、VARBINARY、BLOB 和 TEXT 类型），聚集索引记录只包含指向**溢出页面的20字节指针**。大于或等于`768`字节的固定长度字段被编码为可变长度字段。例如，如果字符集的最大字节长度大于3，则 char(255） 列可能超过768字节， utf8mb4 就是如此。\n\n\n\n> 列是否在页外存储取决于页面大小和行的总大小。当一行太长时，会选择最长的列进行页外存储，直到聚集索引记录适合 B+ 树页面。小于或等于40字节的 [`TEXT`](https://dev.mysql.com/doc/refman/5.7/en/blob.html) and `BLOB` 列存储在行中。\n\n\n\n`DYNAMIC`行格式保持了在索引节点中存储整行的效率（`COMPACT` 和`REDUNDANT` 格式也是如此），但`DYNAMIC`行格式避免了用大量长列数据字节填充 B+ 树节点的问题。\n\n`DYNAMIC`行格式基于这样的思想：如果长数据值的一部分存储在页外，则通常最有效的方法是在**页外存储整个值**。使用 DYNAMIC 格式，较短的列可能保留在 B+ 树节点中，从而最大限度地减少给定行所需的溢出页数。\n\n\n\n>DYNAMIC 行格式支持最多`3072`字节的索引键前缀。此功能由`innodb_large_prefix`变量控制，该变量在默认情况下处于启用状态。\n\n\n\n### COMPRESSED\n\n`COMPRESSED`行格式提供了与`DYNAMIC`行格式相同的存储特性和功能，但增加了对**表和索引数据压缩**的支持\n\n\n\n`COMPRESSED`行格式使用与`DYNAMIC`行格式类似的页外存储内部详细信息，并从压缩的表和索引数据中考虑额外的存储和性能，使用较小的页面大小。对于压缩行格式，`KEY_BLOCK_SIZE`选项控制在聚集索引中存储多少列数据，以及在溢出页上存储多少列数据。\n\n\n\n>COMPRESSED行格式支持最多`3072`字节的索引键前缀。此功能由`innodb_large_prefix`变量控制，该变量在默认情况下处于启用状态。\n\n\n\n使用`COMPRESSED`行格式的表可以在每个表的**文件表空间**或**常规表空间**中创建。**系统表空间不支持压缩行格式**。要在每个表空间的文件中存储压缩表，必须启用`innodb_file_per_table`变量，并且必须将`innodb_file_format`设置为`Barracuda`。innodb_file_per_表和innodb_file_格式变量不适用于常规表空间。通用表空间支持所有行格式，但需要注意的是，**由于物理页大小不同，压缩表和未压缩表不能在同一个通用表空间中共存**。\n\n\n\n总结\n---\n\n### Antelop 文件格式\n\n#### Redundant\n\n- 记录额外信息\n  - 字段偏移长度列表\n  - 记录头信息\n- 记录真实信息（包含隐藏列）\n\n这种行格式存储已经**基本不使用**了，占用空间最多，内存碎片化最严重，性能较差\n\n#### COMPACT\n\n- 记录额外信息\n\n  - 变长字段长度列表\n\n  - NULL 值列表\n\n  - 记录头信息\n\n- 记录真实数据（包含隐藏列）\n\n\n\n### Barracuda 文件格式\n\n加入了 DYNAMIC 和 COMPRESSED 新的行格式存储\n\n#### Dynamic 和 Compressed\n\n- 类似 Compact 行格式，只不过在存储数据发生溢出时的处理方式不一样，Dynamic 是在记录真实数据哪里只存储20字节的页地址，所有字节都存到其他页面中。\n- Compressed 行格式会采取压缩算法对页面进行压缩\n\n","tags":["row formats"],"categories":["Mysql"]},{"title":"编码格式","url":"/2021/11/04/编码格式/","content":"\n编码格式\n\n<!-- more -->\n\n> 基本知识：\n>\n> - 计算机中最小单元为 **一个字节** 【1 byte = 8 bit】 0~(2^8 - 1)\n\n\n\n字符集\n---\n\n> 定义：多个字符的集合； \n>\n> 常见的字符集：\n>\n> 1. **ASCII字符集**\n> 2. **GB2312字符集**\n> 3. BIG5字符集\n> 4. **GB18030字符集**\n> 5. **Unicode字符集**\n\n\n\n### 字符集发展过程\n\n1. ASCII码 【美国，英文字母、标点符号、阿拉伯数字】\n2. Latin-1 【欧洲，加入希腊字母】\n3. GB2312  【中国，加入汉字】\n4. GBK     【加入生僻字，繁体字和日韩汉字】\n5. Unicode 【ISO国际标准化组织一统江湖】\n6. UTF-8   【再编码】\n\n\n\nASCII码字符集\n---\n\n> 全称：美国信息交换标准码，**实现方式与字符集同名**\n>\n> - 只用了一个字节的后 **`7`** bit【第一位`0`】，所以只有 `128` 种字符【`32`个不可打印字符】\n> - 二进制表示\n\n\n\nGB2312字符集\n---\n\n> **实现方式与字符集同名**\n>\n> - 分区表示: GB2312 中对所收汉字进行了“分区”处理，每区含有 94 个汉字/符号。这种表示方式也称为区位码\n> - 双字节表示: 两个字节中前面的字节为第一字节，后面的字节为第二字节。习惯上称第一字节为**高字节** ，而称第二字节为**低字节**。\n\n\n\nGBK字符集\n---\n\n> **实现方式与字符集同名**\n>\n> - 是 GB2312 的扩展\n> - 向上兼容，使用 GB2312 编码的可以使用 GBK 解码\n\n\n\n**Unicode字符集**\n---\n\n> 全称： 统一的字符编码标准\n>\n> - Unicode 只是一个符号集，它只规定了**符号对应的二进制代码**，却没有规定这个二进制代码应该如何存储。\n>\n> - Unicode 是一本字典，他不是一次性定义的，是**分区定义**的，每个区可以存　`2^16` 字符【`65536`】,把它称之为一个**平面**（plane)\n>\n>   目前有`2^5` 平面【`17`】\n>\n>   - BMP【基本平面】：`0 ~ 2^16 - 1` ，（U+0000 到 U+FFFF）\n>   - SMP【辅助平面】：剩下的字符，（U+010000 到 U+10FFFF）\n>\n> - Unicode 有多种实现方式：\n>\n>   - UTF-8 【变长 1 ~ 4 字节】\n>   - UTF-16 【两个 或 四个 字节】\n>   - UTF-32  【四个字节】\n\n\n\n### **UTF-8**\n\n>全称：Unicode 转换格式 8-bit \n>\n>- **utf8是 Unicode 的一种实现方式**\n>- utf-8是一种**变长的编码方式**，使用 **`1` ~ `4`** 个字节表示一个字符\n>  - 如果一个字节的第一位是`0`，则这个字节单独就是一个字符；如果第一位是`1`，则连续有多少个`1`，就表示当前字符占用多少个字节\n\n\n\n### UTF-16\n\n>- 基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节\n>- 当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。\n\n\n\n### UTF-32\n\n> **四个字节**实现 Unicode\n\n\n\n总结\n---\n\n| 主要字符集 | 字符集实现方式      | 备注                                                         |\n| :--------- | :------------------ | :----------------------------------------------------------- |\n| ASCII      | ASCII               | 美国定义的，主要包含英文字母、数字等,128个字符【第一位没用】，32个不可打印字符 |\n| GB2312     | GB2312              | 中国定义，加入汉字                                           |\n| GBK        | GBK                 | 兼容GB2312                                                   |\n| Unicode    | UTF-8/UTF-16/UTF-32 | UTF-8变长【1~4】、UTF-16【2或4】、UTF-32【4】                |","tags":["计算机"],"categories":["计算机"]},{"title":"ubuntu配置","url":"/2021/10/31/ubuntu配置/","content":"\nubuntu配置\n\n<!-- more -->\n\n换源\n---\n\n> 文件位置/etc/apt/sources.list\n\n1. 备份\n\n```shell\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.backup\n```\n\n2. 打开sources.list文件\n\n```shell\nsudo vim /etc/apt/sources.list\n```\n\n3. 删除原来内容，替换为以下内容\n\n```tex\n#阿里云镜像\n\ndeb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n```\n\n4. 更新\n\n```shell\nsudo apt update\nsudo apt upgrade\n```\n\n\n\n取消sudo密码\n---\n\n> 文件位置 /etc/sudoers\n\n1. 打开文件\n\n```shell\nsudo vim /etc/sudoers\n```\n\n2. 添加如下内容\n\n```shell\n#includedir /etc/sudoers.d\nadmin ALL=(ALL)  NOPASSWD:ALL\nyou_name ALL=(ALL) NOPASSWD:ALL\n```\n\n3. 强制退出，wq!\n\n\n\n更换主题\n---\n\n以zsh主题为例\n\n1. 查看当前有什么主题\n\n```shell\ncat /etc/shells\n```\n\n2. 安装zsh\n\n```shell\nsudo apt install zsh\n```\n\n3. 更换当前主题\n\n```shell\nchsh -s /bin/zsh\n```\n\n4. 安装git\n\n```shell\nsudo apt install git\n```\n\n5. 安装oh-my-zsh\n\n```shell\nsh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\"\n```\n\n6. 更换自己喜欢的主题\n\n```shell\nsudo vim ~/.zshrc\n#更改 ZSH_THEME=\"robbyrussell\"\nZSH_THEME=\"ys\"\n```\n\n","tags":["ubuntu"],"categories":["ubuntu"]},{"title":"Java中的集合问题","url":"/2021/06/28/Java中的集合问题/","content":"\n 一些集合总结\n\n<!-- more -->\n\n集合\n---\n\n\n\n### List 、Set、Map\n\n- List：有序（存取元素有序）\n- Set：无序，不重复\n- Map：键值对，key不能重复\n\n\n\n### ArrayList 、LinkedList\n\n- 底层实现：ArrayList 是数组；LinkedLsit是链表\n- 对于index索引数据：ArrayList 直接定位；LinkedList则需要遍历\n- 对于随机插入和删除：ArrayList需要移动目标的后面节点；LinkedList则只需要修改前后节点的属性\n- 对于顺序插入和删除：ArrayList不需要移动节点；比LinkedList效率上高\n\n总结：需要有大量的插入和删除操作，选择LinkedList；需要很多查找操作，插入和删除操作较少，则选择ArrayList\n\n\n\n### ArrayList 、Vector\n\nVector在方法上加了synchronized来确保线程安全，其他多差不多\n\n\n\n### HashMap的底层数据结构\n\n在 jdk 1.8 之前都是“数组+链表”，在 jdk 1.8之后都是\"数组+链表+红黑树\"；\n\n```java\n//负载因子\nDEFAULT_LOAD_FACTOR = 0.75f\n```\n\n\n\n#### 为什么改成\"数组+链表+红黑树\"\n\n主要为了解决hash冲突严重时（链表过长）的查找性能，使用链表的查找性能O(n)，使用红黑树的查找性能时O(log n)\n\n\n\n#### 什么时候用链表，什么时候用红黑树\n\n```java\n//阈值\nTREEIFY_THRESHOLD = 8;\nUNTREEIFY_THRESHOLD = 6;\n//时间和空间的权衡\n```\n\n\n\n#### threshold用途\n\n存放扩容阈值；（容量 * 负载因子）\n\n\n\n#### HashMap容量\n\n```java\nDEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n//最小容量为2的N次方\n```\n\n#### HashMap计算hashCode方法\n\n```java\nreturn (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n//^是异或\n```\n\n当数组的长度很短时，只有低位数的hashcode值能参与运算。而让高16位参与运算可以更好的均匀散列，减少碰撞，进一步降低hash冲突的几率。并且使得高16位和低16位的信息都被保留了\n\n#### jdk 1.8之前为什么会出现死循环\n\njdk 1.7 扩容采用的是\"头插法\"，会导致同一个索引位置的节点在扩容后顺序反掉。jkd 1.8采用的是“尾插法”\n\n### HashMap 和 Hashtable\n\n1. Hashtable是线程安全，它在方法上都加了synchronized来保证线程安全；HashMap不是线程安全\n2. Hashtable的初始容量是11；HashMap的初始容量为16；\n3. Hashtable的扩容为2的N倍 + 1；HashMap的容量始终问2 的指数\n4. Hashtable继承的类是Dictionary；HashMap继承的是AbstractMap\n5. Hashtable是创建时就初始化；HashMap是第一次put时初始化\n6. Hashtable的key和value不允许为空；HashMap可以\n7. Hashtable的hash值是key.hashCode()算出来的；HashMap的hash是重新计算过的\n8. HashMap去掉了 Hashtable 中的contains方法\n\n\n\n### ConcurrentHashMap \n\n数据结构：jdk 1.7 采用 分段的数组 + 链表；jdk 1.8 采用 数组 + 链表 + 红黑树\n\n线程安全：jdk 1.7 采用分段锁 ；jdk 1.8 采用synchronized + CAS (比较并交换)\n\n\n\n###  Comparable 和 Comparator\n\nComparable是自然排序接口；Comparator是比较排序器\n\n\n\n### Collection 和 Collections\n\nCollection是集合类的一个顶级接口；\n\nCollections是集合类的一个工具类/帮助类，提供一系列静态方法\n\n","tags":["Java集合"],"categories":["Java"]},{"title":"JVM垃圾回收机制(GC)","url":"/2021/06/27/JVM垃圾回收机制-GC/","content":"\nJVM垃圾回收机制(GC)\n\n<!-- more -->\n\n垃圾回收器\n---\n\n### 判断对象是否已死\n\n- **引用计数算法**：在对象中添加一个引用计数器，在被引用的时候就加一，当引用失效时，就减一；当引用计数器为0时就是代表该对象不会在被引用。缺点：无法解决对象之间的相互引用问题。\n\n- **可达性分析算法**：从根节点集合\"GC Root Set\" 开始，根据引用关系向下搜索，搜索过程的路径称为\"引用链\"，无法到达的就意味着是垃圾。\n\n  \n\n固定可作为GC Roots的对象包括：\n\n1. 栈帧中的本地变量表中引用的对象；\n2. 方法区中类静态属性引用的对象；\n3. 方法区中常量引用的对象；\n4. 本地方法栈中JNI引用的对象；\n5. Java虚拟机内部的引用；\n6. 所有被同步锁（synchronized）持有的对象；\n7. 反应Java虚拟机内部情况JMXBean、JVMTI中注册的回调、本地代码缓存等。\n\n\n\n### 引用（reference）\n\n- 强引用：普遍存在的引用赋值，只要引用关系还在，GC 永远不会回收被引用的对象,eg:\" Object obj = new Object( )  \"；\n- 软引用：一些有用，但非必须的对象，会在内存溢出之前，被列入第二次回收对象列中；\n- 弱引用：描述那些非必须的对象，强度比软引用更弱一点，只能存活到下一次垃圾收集发生之前；\n- 虚引用：最弱的一种引用关系，为对象设置该引用唯一目的是为了在这个对象被GC回收时收到一个系统通知。 虚引用必须和引用队列（ReferenceQueue）联合使用\n\n\n\n### 堆内存常见的分配策略\n\n- 对象优先进入Eden区分配\n  - 当Eden内存几乎被分配完全了，如果此时再为其他的对象分配内存，虚拟机就会发起一次Minor GC,如果之前的对象无法存入幸存区，只能通过**分配担保机制**将新生代的对象提前转移到老年代中\n- 大对象直接进入老年代\n  - 为什么要这样——为了避免大对象分配内存由于分配担保机制带来的复制导致降低效率\n- 长期存活的对象进入老年代\n  - 虚拟机给每个对象一个对象年龄(Age) 计数器\n\n\n\n### 生存后死亡\n\n即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\n\n被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\n\n\n\n### 如何判断一个常量是废弃常量\n\n运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢?\n\n假如在常量池中存在字符串\"abc\" ,如果当前没有任何String对象引用该字符串常量的话，就说明常量\"abc\"就是废弃常量,如果这时发生内存回收的话而且有必要的话，\" abc\"就会被系统清理出常量池。\n\n### 如何判断一个类是无用的类\n\n方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\n\n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：\n\n- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n- 加载该类的 `ClassLoader` 已经被回收。\n- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。\n\n### 垃圾收集算法\n\n#### 分代收集理论\n\n分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。\n\n- 部分收集（Partial GC）\n  - 新生代收集（Minor GC/Young GC）\n  - 老年代收集（Major GC/Old GC）\n  - 混合收集（Mixed GC）\t\t\n\n- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集\n\n#### 标记-清除算法\n\n标记阶段是把所有活动对象（可达对象，reachable）都做上标记的阶段。 清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段。\n\n缺点：\n\n- 执行效率不稳定\n- 内存空间碎片化问题\n\n\n\n#### 标记-复制算法\n\n它将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。\n\n缺点：\n\n- 内存缩小一半，空间浪费太多\n\n\n\n#### 标记-整理算法\n\n该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存\n\n\n\n### 垃圾收集器\n\n![2021-7-16 1-0](JVM垃圾回收机制-GC/2021-7-161-0.png)\n\n![2021-7-16 1-1](JVM垃圾回收机制-GC/2021-7-161-1.png)\n","tags":["Java","JVM"],"categories":["Java"]},{"title":"JVM类加载机制","url":"/2021/06/27/JVM类加载机制/","content":"\nJVM类加载机制\n\n<!-- more -->\n\n类加载机制\n---\n\n### 类的加载时机（触发条件）\n\n- 使用new关键字实例化对象\n- 读取或设置一个类型的静态字段\n- 调用一个类型的静态方法的时候\n- 反射（使用java.lang.reflect包的方法对类型进行反射调用）\n- 初始化一个类的子类（会首先初始子类的父类）\n- JVM启动标明的启动类，即文件名和类名相同的那个类\n\n### 类的加载过程\n\n- 加载 (Loading)\n- 验证(Verification)\n- 准备(Preparation)\n- 解析(Resoultion)\n- 初始化(Initialization)\n- 使用(Using)\n- 卸载(UnLoading)\n\n注意：静态变量在准备阶段只进行创建；静态常量在准备阶段就会进行初始化\n\n### 类的加载器(ClassLoader)\n\n- 启动类加载器( Bootstrap )：加载存放在lib目录下的jar包、或被-Xbootclasspath参数指定指向的路径中存放的jar包\n- 扩展类加载器( Extension )：加载lib\\ext下的jar包\n- 应用程序类加载器( Application )：加载用户类路径（ClassPath）上所有类库\n- 自定义类加载器( Custom )：继承classLoader，重写findClass方法\n\n\n\n### 双亲委派模型\n\n简单的来说，类加载器永远要先请示上级，上级会请示它的上级，除非所有上级都做不了，这件事才轮到你来\n\n加载过程\n\n<img src=\"JVM类加载机制/ClassLoader.png\" alt=\"ClassLoader\" style=\"zoom:50%;\" />\n\n**不可重写String类**\n","tags":["Java","JVM"],"categories":["Java"]},{"title":"JVM内存结构","url":"/2021/06/27/Java内存区域/","content":"\n内存结构\n\n<!-- more -->\n\nJVM内存结构\n---\n\n### JVM 运行时内存结构图\n\n<img src=\"Java内存区域/JVM-1.png\" alt=\"JVM-1\" style=\"zoom: 33%;\" />\n\n所有线程共享：\n\n- 方法区（Method Area)：也叫元空间，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存的数据【**运行时的常量池也是方法区的一部分**】\n\n  <img src=\"Java内存区域/method-1.png\" alt=\"method-1\" style=\"zoom: 50%;\" />\n\n- 堆区（Heap Area）：占的最大，存放Java**对象的实例**\n\n线程私有（线程独立）：\n\n- 栈区（Stack Area)：每个方法被执行的时候，都会同步创建一个**栈帧**（Stack Frame）用于存储**局部变量表、操作数栈**、动态连接、方法出口等\n\n  <img src=\"Java内存区域/Stack-1.png\" alt=\"Stack-1\" style=\"zoom:50%;\" />\n\n- 程序计数器（Program Counter Register）：一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器\n\n- 本地方法栈（Native Method Area）：调用本地方法，和栈区通过本地方法接口（JNI）通信\n\n\n\n### 堆区（Heap Area)\n\n- 新生代（Young）：又分伊甸区（Eden)、两个幸存区（From Survivor, To  Survivor)\n- 老年代（Old）：\n\n<img src=\"Java内存区域/Heap-1.png\" alt=\"Heap-1\" style=\"zoom:50%;\" />\n","tags":["Java","JVM"],"categories":["Java"]},{"title":"Windows10更新问题","url":"/2021/06/24/Windows10更新问题/","content":"\nwindows10更新问题,抱歉，我们很难确定你的电脑能否运行Windows 10，请关闭安装程序，然后再试一次;\n\n<!-- more -->\n\nwindows10更新问题\n---\n\n### 问题描述：\n\n1、在设置中进行质量或其他更新，重启后在更新配置到99%是，提示无法更新，然后撤销更改；\n\n2、使用易升或更新程序（MediaCreationTool****.exe）更新，提示：“抱歉，我们很难确定你的电脑能否运行Windows 10，请关闭安装程序，然后再试一次。”；如下图。\n\n<img src=\"Windows10更新问题/问题截图.jpg\" alt=\"问题截图\" style=\"zoom:50%;\" />\n\n### 解决方法：\n\n（不一定能解决，只适用特定情况）\n\n1、将C盘空余出40G以上的可用空间（有时20G都不够原因是系统要保留原有系统备份、解压等）\n\n2、win+R 输入msconfig 按回车，选择引导，正常的如下图\n\n<img src=\"Windows10更新问题/windows10-2.png\" alt=\"windows10-2\" style=\"zoom:50%;\" />\n\n如果为空白，会报不能此电脑是否运行的系统，是因为运行msconfig，在引导页中是空白的，看不到引导的系统（但是电脑是正常可以开机的）；造成的原因可能是你最近装过双系统。\n\n3、修复引导，需要一个PE系统的U盘。（网上有很多PE的制作教程）\n\n4、进入PE系统，打开DiskGenius，如下图\n\n![windows10-3](Windows10更新问题/windows10-3.png)\n\n你的可能名字不叫ESP，可能叫分区0或其他的名称，使用DiskGenius指定盘符为x或其它可用盘符。\n\n查看你的分区类型\n\n![windows10-4](Windows10更新问题/windows10-4.png)\n\n我的是GPT，你的可能是MBR\n\n5、打开PE系统的Windows10引导修复软件\n\na、GPT：选择 uefi  ，选择挂载地方（x盘，刚刚指定的盘符）点击修复\n\n注：以上操作仅在我自己出问题的笔记本上操作有效，注意备份数据。\n","tags":["windows10","windows10更新问题"],"categories":["windows10"]},{"title":"HTML","url":"/2021/06/17/HTML/","content":"\nhtml常用标签\n\n<!-- more -->\n\n1、Html简介\n---\n\n​\tHtml 是超文本标记语言；Hyper  Text   Markup    Language\n\n​\t\t\t可以传输出图片外，还有图像、视频、音频和动画等\n\n​\tW3C 标准：\n\n​\t\tWorld  Wide  Web  Consorttium(万维网联盟)\n\n​\t\tW3C包括了\n\n​\t\t1.结构化标准语言（Html、XML）\n\n​\t\t2.表现标准语言（CSS）\n\n​\t\t3.行为标准（DOM,ECMAScript)\n\n\n\n\n\n2、基本结构\n---\n\n```html\n<!--**DOCTYPE**:告诉浏览器，我们要使用什么规范-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<!--head代表网页的头部-->\n<head>\n    <!--meta是描述性标签，用来描述网站的一些基本信息-->\n    <!--meta一般用来做SEO-->\n    <meta charset=\"UTF-8\">\n    <!--title是网站的标题-->\n    <title>Title</title>\n</head>\n<!--body代表网页的主体-->\n<body>\n    基本结构\n</body>\n</html>\n```\n\n\n\n\n\n3、基本标签\n---\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>基本标签</title>\n</head>\n<body>\n<!--标题标签:h-->\n<h1>1级标签</h1>\n<h2>2级标签</h2>\n<h3>3级标签</h3>\n<h4>4级标签</h4>\n<h5>5级标签</h5>\n<h6>6级标签</h6>\n\n<!--段落标签:p-->\n<p>기를 쓰고 사랑해야 하는 건 아냐</p>\n\n<p>하루 정도는 행복하지 않아도 괜찮아</p>\n\n<p>그럼에도 역시 완벽하군 나의 여인 um</p>\n\n<p>여전히 무수한 빈칸들이 있지</p>\n\n<!--换行标签:br-->\n기를 쓰고 사랑해야 하는 건 아냐<br>\n하루 정도는 행복하지 않아도 괜찮아<br>\n그럼에도 역시 완벽하군 나의 여인 um<br>\n여전히 무수한 빈칸들이 있지<br>\n\n<!--水平线标签:hr-->\n<hr>\n\n<!--粗体、斜体:strong ,em-->\n粗体：<strong>I love you</strong> <br>\n斜体：<em>I love you</em>\n\n<!--特殊符号-->\n空格&nbsp;&nbsp;结束 <br>\n大于：&gt; <br>\n小于：&lt; <br>\n版权符号： &copy; <br>\n\n</body>\n</html>\n```\n\n\n\n4、图像标签\n---\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>图像标签</title>\n</head>\n<body>\n<!--img标签讲解\n        **src：图片地址\n            相对地址，绝对地址\n            ../  ----上一级目录\n        **alt:当图片加载失败，会显示这个描述\n        title:当鼠标悬停在图片上显示的文字\n        width:图像宽度\n        height:图像高度\n\n-->\n\n<img src=\"../resources/image/973967.jpg\" alt=\"背景图片\" title=\"悬停文字\" width=\"400\" height=\"200\">\n\n</body>\n</html>\n```\n\n\n\n\n\n5、链接标签\n---\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>链接标签</title>\n</head>\n<body>\n<!--页面间链接-->\n<!--a标签\n    **href: 要跳转到哪个页面\n    target:表示窗口要在哪里打开\n           _blank:在新标签中打开\n           _self:在自己的网页中打开\n-->\n<a href=\"基本标签.html\" target=\"_blank\">跳转到基本标签页面，在新的窗口打开</a>\n<a href=\"https://www.baidu.com\" target=\"_self\">\n    <p>\n        <img src=\"../resources/image/973967.jpg\" alt=\"picture\" width=\"200\" height=\"200\" >\n    </p>\n\n</a>\n<hr>\n<!--锚链接\n1、需要一个锚标记\n2、跳转到标记 #\n-->\n<a id=\"top\">top</a>\n<p>\n    <img src=\"../resources/image/973967.jpg\" alt=\"picture\"  height=\"1000\" >\n</p>\n\n<a href=\"#top\">回到top</a>\n\n<hr>\n<!--功能性标签\n邮件属性：mailto\nqq链接：\n-->\n<!--邮件属性：mailto-->\n<a href=\"mailto:ioutime@163.com\">邮箱地址</a>\n<!--qq链接：-->\n<a target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3&uin=&site=qq&menu=yes\">\n    <img border=\"0\" src=\"http://wpa.qq.com/pa?p=2::51\" alt=\"联系我获取资料\" title=\"联系我获取资料\"/>\n</a>\n\n</body>\n</html>\n```\n\n\n\n6、块元素和行内元素\n\n块元素:\n\n- 无论内容多少，该元素独占一行\n- 例如（p，h1，h2，·····标签）\n\n行内元素：\n\n- 内容撑开宽度，左右都是行内元素的可以排在一行\n- 例如( a,strong,em,·····）\n\n7、列表\n---\n\n7.1、什么是列表：\n\n​\t\t列表就是信息资源的一种展示形式。它可以是信息结构化和条理化，并以列表的样式显示出来，以便浏\t\t览者能够更快捷的获取相应的信息\n\n7.2、列表的分类\n\n- 无序列表\n- 有序列表\n- 自定义列表\n\n![](/img/picture/image-20210516173504958-1621157710086.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>列表</title>\n</head>\n<body>\n<!--有序列表 :or（Order List）\n    应用范围：试卷，问答。······\n-->\n<ol>\n  <li>Java</li>\n  <li>Python</li>\n  <li>C/C++</li>\n</ol>\n<hr>\n<!--无序列表：ur（unorder list)\n    应用范围：导航，侧边栏····\n-->\n<ul>\n  <li>Java</li>\n  <li>Python</li>\n  <li>C/C++</li>\n</ul>\n<hr>\n<!--自定义列表：\n    dl：标签\n    dt：标签名称\n    dd：列表内容\n    应用范围：\n-->\n<dl>\n  <dt>学科</dt>\n\n  <dd>Java</dd>\n  <dd>Python</dd>\n  <dd>C/C++</dd>\n\n  <dt>成绩</dt>\n\n  <dd>98</dd>\n  <dd>89</dd>\n  <dd>90</dd>\n</dl>\n\n</body>\n</html>\n```\n\n\n\n\n\n8、表格\n---\n\n8.1、为什么使用表格\n\n​\t\t\t简单通用；结构稳定\n\n8.2、基本结构\n\n- 单元格\n- 行\n- 列\n- 跨行\n- 跨列\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>表格</title>\n</head>\n<body>\n<!--表格标签：table\n    行：tr rows\n    列：td\n    跨行：rowspan\n    跨列：colspan\n-->\n<table border=\"2px\">\n    <tr>\n        <td>1</td>\n        <td>2</td>\n        <td>3</td>\n        <td>4</td>\n    </tr>\n    <tr>\n        <td>5</td>\n        <td>6</td>\n        <td>7</td>\n        <td>8</td>\n    </tr>\n</table>\n</body>\n</html>\n```\n\n9、媒体元素\n---\n\n视频元素：\n\n​\tvideo\n\n音频元素：\n\n​\taudio\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>媒体元素</title>\n</head>\n<body>\n<!--音频和视频\n    src：资源路径\n    controls:控制条\n    autoplay:自动播放\n-->\n<audio muted src=\"../resources/audio/音频.mp3\" controls autoplay >音频</audio>\n\n<!--<video muted src=\"../resources/video/视频.mp4\" controls autoplay>视频</video>-->\n\n<video muted autoplay>\n    <source src=\"../resources/video/视频.mp4\">\n</video>\n\n</body>\n</html>\n```\n\n10、页面结构分析\n---\n\n| 元素名  |                        描述                        |\n| :-----: | :------------------------------------------------: |\n| header  |  标题头部区域的内容（用于页面和页面中的一块区域）  |\n| footer  | 标记脚部区域的内容（用于整个页面或页面的一块区域） |\n| section |              Web页面中的一块独立区域               |\n| article |                   独立的文章内容                   |\n|  aside  |                   相关内容或应用                   |\n|   nav   |                   导航类辅助内容                   |\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>网页结构分析</title>\n</head>\n<body>\n<!--header-->\n<header>\n  <p>网页头部</p>\n</header>\n<!--section-->\n<section>\n  <p>网页的主体</p>\n</section>\n<!--footer-->\n<footer>\n  <p>网页脚部</p>\n</footer>\n</body>\n</html>\n```\n\n11、iframe内联框架\n---\n\n\n\n```html\n<!DOCTYPE html><html lang=\"en\"><head>    <meta charset=\"UTF-8\">    <title>iframe</title></head><body><!--iframe:    src:地址    w-h：宽高--><iframe src=\"\" frameborder=\"0\" name=\"路飞\"></iframe><a href=\"../resources/video/海贼王混剪.mp4\"  target=\"路飞\">路飞</a></body></html>\n```\n\n\n\n12、post和get提交\n---\n\n### 12.1、表单语法\n\n```html\n<!DOCTYPE html><html lang=\"en\"><head>    <meta charset=\"UTF-8\">    <title>表单</title></head><body><h1>Login</h1><!--表单form：    **action:表单提交的位置    **method：post,get提交方式            get方式提交：我们可以在url中看到我们提交的信息，不安全，高校            post：比较安全，传输大文件--><form action=\"iframe.html\" method=\"get\">  <!--文本框-->  <p>username:<input type=\"text\" name=\"username\"></p>  <!--输入框-->  <p>password: <input type=\"password\" name=\"password\" ></p>  <!--提交和重置-->  <p>    <input type=\"submit\" name=\"登录\">    <input type=\"reset\" name=\"清除\">  </p></form></body></html>\n```\n\n### 12.2、表单元素格式\n\n| 属性      | 说明                                                         |\n| :-------- | :----------------------------------------------------------- |\n| type      | 指定元素类型(text ,password,radio,checkbox,submit,reset,file,hidden,imageh和button...)，默认为text |\n| name      | 指定表单元素的名称                                           |\n| value     | 元素的初始值，type为radio时必须指定一个值                    |\n| size      | 指定表单元素的初始宽度。当type为text或password时，表单元素的大小以字符为单位。对于其他类型，宽度是以像素为单位。 |\n| maxlength | type为text或password时，输入的最大字符数。                   |\n| checked   | type为radio或checkbox时，指定按钮是否被选中                  |\n\n### 12.3、表单元素类型\n\n1. 文本输入框\n2. 密码框\n3. 单选框\n4. 多选框\n5. 按钮\n6. 下拉框\n7. 列表框\n\n\n\n","tags":["html"],"categories":["web"]},{"title":"Java学习笔记","url":"/2021/04/24/Java学习笔记/","content":"\nJava学习笔记\n\n<!-- more -->\n\n基本概念与常识\n---\n\n### Java语言的特点\n\n- 简单易学\n\n- 面向对象（封装、多态、继承）\n\n- 分布式\n\n- 健壮性\n\n- 安全性\n\n- 可移植性(java的虚拟机)\n\n- 解释型\n\n- 高性能\n\n- 多线程\n\n- 动态性\n\n\n### JVM、JDK、JRE\n\n- JVM：Java的虚拟机，是运行Java字节码的虚拟机。JVM有针对不同操作系统的特定实现，目的是生成相同的字节码。\n\n- 字节码：JVM 可以理解的代码，也就是我们看到的 文件名.class 的文件。字节码不面向任何特定的处理器，只面向JVM。\n\n- 源码到运行的过程，如下\n\n  .java的源文件    ----JDK中的javac编译-->  .class文件    -----JVM--->  二进制机器码\n\n- JDK：全称Java Development Kit , 它是功能齐全的Java SDK （软件开发工具包）。它拥有 JRE 所拥有的一切，还有 编译器（javac） 和 工具（如：javadoc 和 jdb)。可以创建和编译程序\n\n- JRE： 全称 Java Runtime Environment，Java运行时的环境,包括了 JAM 、 Java类库 、java命令和其他的一些基础构件。但是，他不能用于创建新程序。\n\n\n总的来说，JDK > JRE > JVM\n\n\n\n### JAVA 语言“编译与解释并存”?\n\n编译型：一次性将源码翻译成机器码，然后在执行；\n\n解释型：一边编译一边运行\n\njava语言也具有编译型语言的特点，Java的源程序要先编译成字节码，然后进行解释。\n\n\n\n### Oracle JDK 和 Open JDK\n\n- Oracle JDK 不是完全开源；Open JDK 是开源的；\n\n- Oracle JDK 比 Opea JDK 更稳定\n\n- 在响应性和JVM性能方面，Oracle　JDK更好一点\n\n\n\n\n### import java 和 javax有什么区别\n\n刚开始的JavaAPI 所必需的包是Java开头的包，Javax 当时只是用来扩展API的。\n\n后来，javax 逐渐成为 Java API 的组成部分。由于移动麻烦，最终 javax 包成为标准API的一部分\n\n所以，java和javax 没什么区别。\n\n\n\n基本语法\n---\n\n\n\n### 字符型常量和字符串常量有什么区别\n\n- 形式 ：' a '      “aaaaa”\n- 含义：相当于一个整型值（ASCII 值），可以运算； 代表一个地址值\n- 内存大小：2个字节   ； 若干个字节\n\n\n\n### 注释：\n\n- 单行注释\n- 多行注释\n- 文档注释\n\n\n\n### 标识符、关键字\n\n标识符：自己取的名字\n\n关键字：Java 语言已经赋予了其特殊含义，只能用于特定的地方，特殊的标识符\n\n\n\n### Java泛型，类型擦除\n\n泛型使用方式\n\n- 泛型类\n- 泛型接口\n- 泛型方法\n\n泛型：本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。\n\nJava的泛型是伪泛型，在java编译期间，所有的泛型信息都会擦除，就是**类型擦除**\n\n\n\n### == 和 equals 的区别\n\n- ==是对基本数据类型是值比较， 对引用数据类型，比较的是对象的内存地址。\n- equals() 只能用于判断对象是否相等\n\nequals()方法的使用存在两种情况\n\n- 类没有重写equals()方法：等价于使用 \"==\" 比较两个对象\n- 类重写了equals() 方法：\n\n\n\n### hashCode() 与 equals()\n\n- hashCode()：作用是获取哈希码，也称散列码。它实际上返回一个**int**整数\n  - 哈希码作用：确定该对象在哈希表中的索引位置\n  - hashCode()：可以减少equals的使用次数，提高执行速度\n\n- 重写equals 时要重写 hashCode 方法\n\n     **两个相等的对象必须具有相等的散列码（Java关键约定）**\n\n  \n\n  ​\t\t\n\n\n\n基本数据类型\n---\n\n\n\n### 基本数据类型、包装类型、字节\n\n| 基本数据类型 | 字节 | 包装类型（引用类型） |\n| :-:| :--: | :--: |\n| int | 4 | Integer |\n| long | 8 | Long |\n| short | 2 | Short |\n| byte | 1 | Byte |\n| char | 2 | Character |\n| float | 4 | Float |\n| double | 8 | Double |\n| boolean | - | Boolean |\n\n\n\n### 自动装箱、拆箱\n\n- 装箱：将基本类型自动转化为对应的引用类型\n\n- 拆箱：将包装类型转换位基本类型\n\n  \n\n```java\n装箱:Integer i = 9;   ===== Integer i = Integer.valueOf(9);\n拆箱:int n = i;       ===== int n = i.intValue();\n```\n\n**注：包装类型比较是否相等，要哟equals()方法**\n\n\n\n\n\n高频面试题\n---\n\n\n\n### String 、StringBuilder、StringBuffer\n\n- String：String的值被创建后不能修改，任何修改都会引发新的String对象的生成\n- StringBuffer：和String 类似，但是值是可以被修改的，使用 synchronized来保证线程安全\n- StringBuilder：非线程安全\n\n\n\n### 反射\n\n反射指的在运行状态中， 对于任意一个类都能知道这个类所有的属性和方法；平且对于任意一个对象，都能调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为反射机制。\n\n\n\n### 深拷贝、浅拷贝\n\n数据分为基本数据类型和引用数据类型。\n\n基本数据类型：数据是直接存放在栈中的\n\n引用数据类型：存放在栈中的是对象的引用地址，真实的对象存放在堆内存中\n\n浅拷贝：对于基本数据类型，直接复制其数据；对于引用数据类型，拷贝的是其对象的引用地址，新旧对象指向的相同的内存地址，无论修改哪个，另一个一会改变\n\n深拷贝：对于基本数据类型，直接复制其数据；对于引用数据类型，深拷贝是在内存中开辟新的空间，在新的内存空间中复制一个一模一样的对象，新老对象不共享内存，修改一个不会修改另一个。\n\n\n\n### 并发、并行\n\n并发：两个或两个以上事件在同一时间间隔内发生。\n\n并行：两个或两个以上事件在同一时刻发生\n\n\n\n### 构造器不可以被重写\n\nConstructor 不能被重写（Override) ，但是可以被 重载（overload）\n\n\n\n### Java只有值传递，对于对象参数，值得内容是对象的引用。\n\n\n\n### 静态变量 和 成员变量\n\n- 静态变量存放在方法区中；成员变量存放在堆内存中\n\n- 静态变量与 类 共存亡；成员变量与 对象 共存亡\n\n- 静态变量属于类；成员变量属于对象\n\n- 静态变量可以被对象调用，也可以被类名调用；成员变量只能被对象调用。\n\n  \n\n### 静态方法内部 能否发出对 非静态方法的调用\n\n- 如何没用显示创建对象的实例，则不可以调用。\n- 显示的创建对象实例，可以调用。\n\n### 重载和重写\n\n方法的重载和重写都是实现多态的方式，重载是编译时的多态性，重写时运行时的多态性。\n\n- 重载：overload，一个类中有多个相同名字的方法，但是具有不同的参数列表（参数类型不同、参数个数不同或两者都不一样）\n- 重写：override，发生在父类和子类之间，子类对父类的方法进行重写，参数不能改变，返回值可以修改，但必须时父类返回值的派生类。\n\n### abstract class (抽象类) 和 interface (接口) \n\n- 抽象类只能单继承；接口可以多实现\n\n- 抽象类可以有构造方法；接口不能有\n\n- 抽象类中可以有成员变量；接口中没有，只能时常量（默认 public static final)\n\n- 抽象类中可以包含非抽象方法；在java 7 之前 接口中所有方法都是抽象的，在Java 8之后\n\n  接口支持非抽象方法：default 方法、静态方法等。Java 9 支持稀有方法，稀有静态方法\n\n- 抽象类中的抽象方法可以是任意修饰符；Java 8之前接口方法只有public类型，在Java9之后支持private\n- 接口时自上而下的，接口规范了某些行为，是对一行为的抽象；抽象类是自下而上的抽象过程，抽象类提供了通用实现，是对某一类事物的抽象。\n\n\n\n### Error  和  Exception 的区别\n\n- Error  和  Exception 都是 Throwable  的子类，用于表示程序不正常情况\n- Error 表示系统级的错误和程序不必处理的异常。\n- Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计和实现的问题。\n\n\n\n### final关键字\n\n- 修饰类：该类不能派生出新的子类，不能作为父类被继承；一个类不能同时被声明为abstract 和 final\n- 修饰方法：该方法的子类不能被重写\n- 修饰变量：该变量必须在声明时给定初始值，不能再被修改，只能被读取；如果该变量是对象，则指的是引用不可改变，但是对象的属性还是可以修改的。\n\n\n\n### finally、finalize\n\n- finally：是对java异常处理机制的最佳补充，通常配合try 、catch使用。通常用于释放锁、数据库连接等资源。\n- finalize：是Object 中的方法，在垃圾收集器将对象从内存中清除出去之前必须要的清理工作。finalize()方法在java 9 之后被弃用。\n\n\n\n### try、catch、finally\n\n在return 之前，会保存要返回的值，然后执行 finally中的语句（如果finally中有retrun 则结束，不会再回到之前的return中。）\n\n\n\n### Java 1.8 之后的特性\n\n接口默认方法：Java 8 之后允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字\n\nLambda 表达式和函数式接口：本质是一段匿名内部类，也可以是一段可以传递的代码\n\nStream API ：\n\n方法引用：\n\n日期时间API：\n\nOptional 类：\n\n新工具：新的编译工具\n\n\n\n### wait() 和 sleep() 方法\n\n- wait() 来自 Object 类；sleep() 来自 Thread 类\n- wait() 会释放同步锁，让其它线程进入synchronized代码块执行；sleep() 不会释放同步锁\n- wait() 只能在同步控制方法或块中里面才能使用，否则会报错IllegalArgumentException\n- wait()需要其他线程掉用同一对象的notify()/notifyAll() 才能恢复；sleep()在时间到了之后会自动恢复\n\n\n\n### 线程的sleep()方法和yield()方法\n\n线程执行sleep() 方法之后进入超时等待（TIMED_WAITING）状态；执行yield() 方法进入就绪等待\n\n- sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程运行的机会\n- yield()方法只会给相同优先级或更高的优先级的线程以运行的机会\n\n\n\n### 线程的 join() 方法\n\n用于等待当前线程终止。\n\n\n\n### 多线程程序的实现\n\n- 继承Thread 类，重写run() 方法，无返回值void\n- 实现Runnable 接口，重写 run() 方法，无返回值void\n- 实现Callable 接口\n\n\n\n### Thread 调用 start() 方法和 run() 方法\n\nrun() ：普通方法的调用，在主线程中执行，不会创建一个线程来执行\n\nstart()：启动一个新的线程，这是这个线程处于就绪态，一但的到cpu的时间片，就开始执行run()方法\n\n\n\n### 线程的状态\n\n![view](Java学习笔记/view.jpg)\n\n- 初始（NEW)：新建但是没有调用start()方法\n\n- 运行（RUNNABLE)：包含就绪（READY）和 运行中（RUNNING）\n\n  - 就绪（READY)：调用start() 方法，等待获取时间片\n\n  - 运行中（RUNNING)：获取到时间片\n\n    就绪  <------系统调度（yield）-----> 运行中\n\n- 阻塞（BLOCKED）：\n\n- 等待（WAITING)：\n- 超时等待（TIMED_WAITING）：\n- 终止（TERMINATED）：\n\n​\t\n\n### synchronized 和 Lock 的区别\n\n- Lock是一个接口；synchronized是Java中的关键字\n- Lock在发生异常，如果没有主动通过unLock() 去释放锁，会造成死锁；synchronized则不会；\n- Lock的使用更加灵活，有响应中断、超时时间；\n\n\n\n### 死锁\n\n- 互斥条件：一段时间内某资源只能被一个线程占用\n- 请求和保持条件：进程已经获得一个资源，但又对另一个资源发出请求，而该资源被另一个进程占用\n- 不可抢占条件：不可强制剥夺\n- 环路等待条件\n\n\n\n### 线程池\n\n常用线程池（线程池是一个典型的“用空间换时间”的应用案例）\n\n- FixedThreadPool:线程数固定的线程池\n- SingleThreadExecutor：线程数量为1的线程池\n- CachedThreadPool：缓存线程池\n\n使用：ExecutorService是所有的线程池都实现了的接口，用这个接口可以定义句柄\n\n​\t\t   Executors类用于创建不同种类的线程池\n\n```java\n//定义一个有5个线程的线程池\nExecutorService fixedTP = Executors.newFixedThreadPool(5); \nExecutorService singleTE = Executors.newSingleThreadExecutor();\nExecutorService cachedTP = Executors.newCachedThreadPool();\n```\n\n优点：\n\n- 降低资源消耗\n- 提高响应速度\n- 增加线程的可管理性\n\n核心属性：\n\n- threadFactory(线程工厂)：\n- corePoolSize(核心线程数)：\n- workQueue（队列）：\n- handler（ 拒绝策略）：\n- keepAliveTime（保持存活时间）：\n\n拒绝策略\n\n- AbortPolicy：中止策略，默认的，使用该策略会抛出异常，阻止系统继续运行\n- DiscardPolicy：抛弃策略，什么都不做，直接抛弃拒绝的任务\n- DiscardOldestPolicy：抛弃最老策略，抛弃阻塞队列中最老的任务\n- CallerRunsPolicy：调用者运行策略，\n\n工作流程：\n\n1. 调用Excutors类的静态方法newCachedThreadPool 或 newFixedThreadPool\n2. 调用submit 提交 Runnable 或 Callable 对象\n3. 保存好返回的Future 对象，以便得到结果或取消任务\n4. 但不想再提交任何任务时，调用shutdown\n","tags":["Java"],"categories":["Java"]}]