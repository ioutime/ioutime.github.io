[{"title":"Java 环境配置","url":"/2023/02/08/Java-Config/","content":"\nJava 环境配置，主要有 JDK 1.8、Maven 和 Tomcat。\n\n<!-- more -->\n\n## JDK\n\n### 安装\n\n> 注：使用 zip 安装的，jdk exe转换为zip(https://bgasparotto.com/convert-jdk-exe-zip)\n\n### 新建系统变量\n\n变量名：JAVA_HOME\n\n变量值：D:\\Environment\\JDK\\jdk-8 (注：jdk 安装路径)\n\n### 编辑系统变量中的Path\n\n>新增:\n>%JAVA_HOME%\\bin\n>%JAVA_HOME%\\jre\\bin\n\n### 验证\n\n```shell\njava -version\njavac -version\n```\n\n\n\n## Maven\n\n### 下载\n\n地址：https://maven.apache.org/download.cgi\n\n### 配置环境变量\n\n新建系统变量：\n\n\t变量名：Maven_Home\n\t变量值：D:\\Environment\\Maven\\apache-maven-3.8.1\n\n编辑系统变量中的Path\n\n\t新增：%Maven_Home%\\bin\n\n注：验证是否配置成功 `mvn -v`\n\n### 配置本地仓库\n\n1、在安装目录的同级目录下新建一个文件夹 maven-repo(`文件名随意`)，如下\n\n```shell\n.\n├── apache-maven-3.8.1\n└── maven-repo\n```\n\n2、修改配置为本地仓库地址，增加如图所示一行（配置文件在conf下）\n\n![image-20230209221614209](Java-Config/image-20230209221614209.png)\n\n```xml\n<localRepository>D:\\Environment\\Maven\\maven-repo</localRepository>\n```\n\n\n\n### 修改源\n\n在setting.xml文件中，找到 <misrrors> 标签，修改如下，以`阿里云仓库`为例\n\n```xml\n<mirrors>\n    <mirror>\n      <id>nexus-aliyun</id>\n      <mirrorOf>central</mirrorOf>\n      <name>Nexus aliyun</name>\n      <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n\t</mirror>\n    <mirror>\n      <id>maven-default-http-blocker</id>\n      <mirrorOf>external:http:*</mirrorOf>\n      <name>Pseudo repository to mirror external repositories initially using HTTP.</name>\n      <url>http://0.0.0.0/</url>\n      <blocked>true</blocked>\n    </mirror>  \n</mirrors>\n```\n\n\n\n## Tomcat\n\n### 下载\n\n地址：https://tomcat.apache.org/download-10.cgi\n\n### 配置环境变量\n\n新建系统变量\n\n```\n变量名：CATALINA_HOME\n变量值：D:\\Environment\\Tomact\\apache-tomcat-9.0.52\n\n变量名：CLASSPATH\n变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;\n```\n\n编辑系统变量中Path\n\n```\n%CATALINA_HOME%\\lib\n%CATALINA_HOME%\\bin\n```\n\n","tags":["Java"],"categories":["Java"]},{"title":"nvm 安装与配置","url":"/2023/02/08/nvm/","content":"\nnvm 全名node.js version management，是一个nodejs 的版本管理工具。\n\n<!-- more -->\n\n#### 安装\n\n>GitHub : https://github.com/coreybutler/nvm-windows/releases\n\n#### nvm 换源(淘宝)\n\n```shell\nnode_mirror: https://npm.taobao.org/mirrors/node/\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\n```\n\n#### nvm 常用命令\n\n```shell\n#查看安装的所有node的版本\nnvm list\n\n#查看当前可安装的版本\nnvm list available\n\n#安装xx.xx.xx版本的node\nnvm install 14.16.0\n\n#使用（切换到）xx.xx.xx版本的node\nnvm use 14.16.0\n\n#卸载xx.xx.xx版本的node\nnvm uninstall 14.16.0\n\n#显示node是运行在32位还是64位。\nnvm arch\n\n#设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。\nnvm proxy [url]\n\n#设置node镜像。默认是https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。\nnvm node_mirror [url]\n\n#设置npm镜像。https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。\nnvm npm_mirror [url]\n\n#设置存储不同版本node的目录。如果未设置，默认使用当前目录。\nnvm root [path]\n```\n\n#### 例子\n\n```shell\n#安装 node 14.16.0\nnvm install 14.16.0\nnvm use 14.16.0\nnpm -v\n```\n\n","tags":["nvm"],"categories":["nvm"]},{"title":"Git 安装与配置","url":"/2023/02/08/Git-Config/","content":"\ngit 安装与配置\n\n<!-- more -->\n\n#### 安装 git 软件\n\n> 地址：https://git-scm.com/download/win\n\n#### 配置全局用户名和邮箱\n\n```shell\ngit config --global user.name \"xxx\"\ngit config --global user.email \"xxx\"\n```\n\n#### 配置 `ssh` 免密登录\n\n```shell\n#创建文件夹 (如果不存在的话)\nmkdir ~/.ssh\n#切换到 ssh 文件夹下\ncd ~/.ssh\n#生成 一直默认\nssh-keygen -t rsa -C \"邮箱\"\n#复制~/.ssh/ 路径下的id_rsa.pub文件中的全部内容（去github、gitee）\n```\n","tags":["git"],"categories":["git"]},{"title":"Linux 一些功能","url":"/2022/04/17/Linux/","content":"\nLinux 一些功能\n\n<!-- more -->\n\ncrontab 定时任务\n---\n\n1.编辑定时任务\n\n```shell\ncrontab -e\n```\n\n![image-20220417003236733](Linux/image-20220417003236733.png)\n\n> 第一次会弹出编辑器选择，建议选择 /usr/bin/vim.basic 编辑器，选错了可以使用 select-editor 重新选择\n\ncron 表达式不会可以去 [crontab guru](https://crontab.guru/) 网站\n\n格式：\n\n```shell\n0 7 * * *  python3 index.py >> /tmp/test.txt\ncron 表达式 运行的指令 日志保存地址\n```\n\n2.查看定时任务\n\n```shell\ncront\n```\n\n\n\n","tags":["linux"],"categories":["linux"]},{"title":"Java Thread","url":"/2021/11/08/Java-Thread/","content":"\njava 多线程\n\n<!-- more -->\n\n多线程的创建\n---\n\n1. 继承Thread类【不建议】\n   - 继承Thread类\n   - 重写run方法\n\n```java\nclass MyThread extends Thread{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"执行了\");\n    }\n\n}\n\npublic class ThreadDemo01 {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread thread = new MyThread();\n        thread.setName(\"子线程\");\n        thread.start();\n        System.out.println(Thread.currentThread().getName()+\"执行了\");\n    }\n}\n\n//main执行了\n//子线程执行了\n```\n\n\n\n2. 实现Runnable【推荐】\n   - implements Runnable\n   - 重写run方法\n   - 传进Thread()中\n\n```java\npublic class RunnableDemo {\n    public static void main(String[] args) {\n        MyRunnable runnable = new MyRunnable();\n        Thread thread = new Thread(runnable,\"runnable\");\n        thread.start();\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n\nclass MyRunnable implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName()+\"执行了\");\n    }\n}\n```\n\n3. 实现Callable\n   - 实现Callable，重写call方法\n   - 创建线程池，Executors.newCachedThreadPool()\n   - submint\n   - shutdown\n\n```java\npublic class CallableDemo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        MyCallable myCallable = new MyCallable();\n        ExecutorService executor = Executors.newCachedThreadPool();\n        Future<Boolean> submit = executor.submit(myCallable);\n        System.out.println(submit.get());\n        executor.shutdown();\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n\nclass MyCallable implements Callable<Boolean> {\n\n    @Override\n    public Boolean call() throws Exception {\n        System.out.println(Thread.currentThread().getName());\n        return true;\n    }\n}\n\n//结果\npool-1-thread-1\ntrue\nmain\n\n```\n\n\n\n静态代理\n---\n\n总的来说：\n\n - **真实对象** 和 **代理对象** 都要实现同一个接口；\n - **代理对象** 要代理 **真实对象**\n\n特点：\n\n - 代理对象能做很多真实对象不能做的事情\n - 真实对象专注完成自己的\n\n \n\n> 通过Runnable实现多线程，就使用了静态代理【new Thread(new MyRunnable))】\n\n\n\n## 线程状态（6个）\n\n1. new 【新建】\n2. running 【可运行】\n3. blocked 【阻塞】\n4. waiting 【等待】\n5. timed waiting 【定时等待】\n6. terminated 【死亡】\n\n> 获取线程状态方法，Thread.getState();\n\n\n\n线程停止的方法\n---\n\n1. 正常停止\n2. 利用标志位停止\n\n\n\n## Tread中的部分方法\n\n- void join() --- 等待终止指定的线程\n\n> 【插队】\n\n```java\npublic class DemoJoin {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(new TestJoin());\n        thread.setName(\"插队\");\n        thread.start();\n        for (int i = 0; i <= 5; i++) {\n            System.out.println(Thread.currentThread().getName()+\":\"+i);\n            if(i == 3){\n                thread.join();\n            }\n        }\n    }\n}\n\nclass TestJoin implements Runnable{\n    @Override\n    public void run() {\n        for (int i = 0; i <= 5; i++) {\n            System.out.println(Thread.currentThread().getName()+\":\"+i);\n        }\n    }\n}\n\n//run\nmain:0\nmain:1\nmain:2\nmain:3\n插队:0\n插队:1\n插队:2\n插队:3\n插队:4\n插队:5\nmain:4\nmain:5\n\nProcess finished with exit code 0\n```\n\n\n\n- void join(long millis)  --- 等待指定的线程终止 或 等待经过指定秒数\n\n- Thread.State getState() --- 线程状态\n\n- void stop() --- 停止该线程（已废弃）\n\n- void suspend() --- 暂停这个线程的执行（已废弃）\n\n- void resume() --- 恢复线程（已废弃）\n\n- static void yield() --- 静态方法，交出运行权\n\n> yield---【礼让】\n>\n> 虽然交出了运行资源，但是下个运行**线程**还是要看 **CPU ** 调度\n\n## 线程状态转化\n\nNew　－－－＞　Runnable\n\n- 调用start()方法，进入Runnable，等待cup时间片\n\n- 一个线程不能重复调用start()即，**线程死亡之后不可重复调用**【start方法中有检测线程状态】\n\n  > start()方法源码\n\n  ```java\n  public synchronized void start() {\n      if (threadStatus != 0)\n          throw new IllegalThreadStateException();\n  \n      group.add(this);\n  \n      boolean started = false;\n      try {\n          start0();\n          started = true;\n      } finally {\n          try {\n              if (!started) {\n                  group.threadStartFailed(this);\n              }\n          } catch (Throwable ignore) {\n  \n          }\n      }\n  }\n  ```\n\nblocked\n\n- 试图获得锁，会进入blocked\n\n\n\n守护线程daemon\n---\n\n> - Thread.setDaemon();\n>\n> - 每个程序都有守护线程如**gc**等\n> - jvm不需要等待守护线程的结束，就可以退出了\n\n## 中断线程\n\nvoid interrupt() --- 向线程发送中断请求，线程的中断状态设置为true（默认false）\n\nstatic boolean interrupted()  --- 测试当前线程是否被中断，会将中断状态设置重置为false\n\nboolean isInterrupted() --- 测试线程是否被中断\n\nstatic Thread currentThread() --- 返回当前正在执行的线程Thread对象\n\n\n\n## 进程间的通信方式\n\n1. 锁和同步\n2. 等待/通知机制\n3. 信号量\n4. 管道\n5. 其它方法：\n   - join()\n   - sleep()\n   - ThreadLocal类\n\n\n\n线程池\n---\n\n### 重要的类和接口\n>\n>| 类                          | 用途                                                         |\n>| :-------------------------- | :----------------------------------------------------------- |\n>| ExecutorService             | 真正实现线程池的接口                                         |\n>| ScheduledExecutorService    | 能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。    |\n>| ThreadPoolExecutor          | ExecutorService的默认实现。                                  |\n>| ScheduledThreadPoolExecutor | 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现 |\n\n\n\n> Executor----**接口**\n\n```java\npublic interface Executor {\n    \n    void execute(Runnable command);\n    \n}\n```\n\n\n\n> Executors --- 提供静态工厂方法用于创建各种线程池的**类**\n\n```java\npublic class Executors {\n    //创建固定数量的线程池\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n    \n    public static ExecutorService newWorkStealingPool(int parallelism) {\n        return new ForkJoinPool\n            (parallelism,\n             ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n             null, true);\n    }\n  \n    public static ExecutorService newWorkStealingPool() {\n        return new ForkJoinPool\n            (Runtime.getRuntime().availableProcessors(),\n             ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n             null, true);\n    }\n    //创建固定数量的线程池\n    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n    }\n    //创建一个单线程的线程池\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n    //创建一个单线程的线程池\n    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>(),\n                                    threadFactory));\n    }\n    //创建一个可缓存的线程池\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n    //创建一个可缓存的线程池\n    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>(),\n                                      threadFactory);\n    }\n\n    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {\n        return new DelegatedScheduledExecutorService\n            (new ScheduledThreadPoolExecutor(1));\n    }\n    \n    public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {\n        return new DelegatedScheduledExecutorService\n            (new ScheduledThreadPoolExecutor(1, threadFactory));\n    }\n    \n    ......\n}\n```\n\n\n\n> ExecutorsService --- 线程池定义的**接口**，继承Excutor，用于线程的操作【shutdown】\n\n```java\npublic interface ExecutorService extends Executor {\n\t//关闭\n    void shutdown();\n\n    List<Runnable> shutdownNow();\n\t//判断\n    boolean isShutdown();\n\n    boolean isTerminated();\n\n    boolean awaitTermination(long timeout, TimeUnit unit)  throws InterruptedException;\n\t//提交\n    <T> Future<T> submit(Callable<T> task);\n\n    <T> Future<T> submit(Runnable task, T result);\n\n    Future<?> submit(Runnable task);\n\t\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;\n\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n\n```\n\n### ThreadPoolExecutor \n\n> ThreadPoolExecutor 是ExecutorService的默认实现\n>\n> 构造方法中参数介绍\n>\n> - corePoolSize : 核心池的大小\n> - maximumPoolSize : 线程池最大线程数\n> - keepAliveTime : 表示线程没有任务执行时最多保持多久时间会终止\n> - unit : 参数keepAliveTime的时间单位\n> - workQueue : 一个阻塞队列，用来存储等待执行的任务\n> - threadFactory : 线程工厂，主要用来创建线程；\n> - handler : 表示当拒绝处理任务时的策略\n>   - ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 \n>   - ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 \n>   - ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\n>   - ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 \n\n```java\n//只取了ThreadPoolExecutor的四个构造方法\npublic class ThreadPoolExecutor extends AbstractExecutorService {\n    .....\n\n \tpublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), defaultHandler);\n    }\n    \n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             threadFactory, defaultHandler);\n    }\n \n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              RejectedExecutionHandler handler) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), handler);\n    }\n \t//前三个最终都调用了这个方法\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.acc = System.getSecurityManager() == null ?null : AccessController.getContext();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n    ...\n}\n```\n\n\n\n### 实例创建线程池\n\n> newCachedThreadPool -- 创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程\n\n```java\npublic class PoolDemo {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        for (int i = 0; i < 20; i++) {\n            executorService.execute(()->{\n                System.out.println(Thread.currentThread().getName());\n            });\n        }\n        executorService.shutdown();\n\n    }\n}\n```\n\n> newFixedThreadPool --- 创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待\n\n```java\nclass FixedThreadDemo{\n    public void run(){\n        ExecutorService executorService = Executors.newFixedThreadPool(5);\n        for (int i = 0; i < 30; i++) {\n            executorService.execute(()->{\n                System.out.println(Thread.currentThread().getName());\n            });\n        }\n        executorService.shutdown();\n    }\n}\n```\n\n> newSingleThreadPool -- 创建一个单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行\n\n```java\nclass SingleThreadDemo{\n    public void run(){\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        for (int i = 0; i < 30; i++) {\n            executorService.execute(()->{\n                System.out.println(Thread.currentThread().getName());\n            });\n        }\n        executorService.shutdown();\n    }\n}\n```\n\n\n\n> newScheduledThreadPool -- 创建一个周期性的线程池，支持定时及周期性执行任务\n\n```java\nclass ScheduledThreadDemo{\n    public void run(){\n        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(3);\n        System.out.println(\" 提交任务\");\n        for (int i = 0; i < 10; i++) {\n            final int index = i;\n            executorService.schedule(() -> {\n                // 获取线程名称,默认格式:pool-1-thread-1\n                System.out.println(Thread.currentThread().getName() + \" \" + index);\n            }, 3, TimeUnit.SECONDS);\n        }\n        executorService.shutdown();\n    }\n}\n```\n\n\n\n> ThreadPoolExecutor -- 【推荐使用，根据需求创建合适的线程池】\n\n```java\nclass ThreadPoolExecutorDemo{\n    public void run() throws InterruptedException {\n        ExecutorService executorService = new ThreadPoolExecutor(100, 1000,\n                1, TimeUnit.MINUTES, new ArrayBlockingQueue<>(5, true),\n                Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n        for (int i = 0; i < 2000; i++) {\n            executorService.execute(()->{\n                System.out.println(Thread.currentThread().getName());\n            });\n            sleep(2);\n        }\n        executorService.shutdown();\n    }\n}\n```\n\n\n\n重要知识点\n---\n\n### 使用线程池的好处\n\n- **降低资源消耗**：通过池化的技术重复利用被创建的线程，降低线程创建和销毁造成的开销\n- **提高响应速度**：当任务到达时，无需等待线程创建即可立即执行\n- **提高线程的可管理性**：**线程是稀缺资源**，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。**使用线程池可以进行统一的分配、调优和监控**。\n- **提供更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能\n\n\n\n### 线程池解决的核心问题\n\n> 线程池解决的核心问题就是**资源管理问题**\n>\n\n在并法的环境下，系统不确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这样的不去确定性会带来问题：\n\n1. 频繁申请/销毁资源和调度资源，将带来**额外的消耗**，可能会非常巨大。\n2. 对资源无限申请缺少抑制手段，**易引发系统资源耗尽的风险**。\n3. 系统无法合理管理内部的资源分布，会降低**系统的稳定性**。\n\n为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想\n\n\n\n### ThreadPoolExecutor是如何运行\n\n线程池的运行主要分成两部分：任务管理、线程管理。\n\n![img](Java-Thread/ThreadPoolExecutor.png)\n\n\n\n### 生命周期管理\n\n线程池内使用一个变量维护两个变量：**运行状态**(runState)和**线程数量** (workerCount--有效线程数)\n\n线程池有五种状态：\n\n1. RUNNING     -- 能接收新提交的任务，也可以处理阻塞队列的任务\n2. SHUTDOWN    -- 关闭状态，不可以接收新的任务，但是可以继续处理阻塞队列的任务\n3. STOP        -- 不接收新的任务，也不处理阻塞队列中的任务，会中断正在处理任务的线程\n4. TIDYING     -- 所有任务都终止了，workerCount（有效线程数）为 0\n5. TERMINATED   -- 在terminated（）方法之后进入这个状态\n\n\n\n生命周期的转化\n\n![图3 线程池生命周期](Java-Thread/ThreadPool-state.png)\n\n### 任务调度\n\n> 所有任务的调度都是由**execute方法**完成的\n\n执行过程如下：\n\n1. 首先检查线程池的状态，如果不是Running，直接拒绝执行\n2. 如果workerCount < corePoolSize ,则创建并启动一个线程来执行该任务\n3. 如果workerCount >= corePoolSize && 阻塞队列未满，则将该任务放入阻塞队列中\n4. 如果workerCount >= corePoolSize && workerCount < maximumPoolSize ,且阻塞队列已满，则创建并启动一个线程来执行该任务\n5. 如果workerCount >= maximumPoolSize ,并且线程池内的阻塞队列已满，则根据**拒绝策略来处理该任务**, **默认的处理方式是直接抛异常**\n\n### 拒绝策略\n\n当线程数量大于maximumPoolSize，就会执行拒绝策略。ThreadPoolExecutor类中一共有4种拒绝策略。\n\n通过实现**RejectedExecutionHandler**接口。\n\n- AbortPolicy【终止策略】 ： 线程任务丢弃报错。默认饱和策略。\n- DiscardPolicy 【丢弃策略】： 线程任务直接丢弃不报错。\n- DiscardOldestPolicy 【丢弃阻塞队列中的最老策略】： 将workQueue**队首任务丢弃**，将最新线程任务重新加入队列执行。\n- CallerRunsPolicy 【直接调用run方法】：线程池之外的线程直接调用run方法执行。\n","tags":["Thread"],"categories":["Java"]},{"title":"InnoDB Page Formats","url":"/2021/11/07/InnoDB-Page-Formats/","content":"\nInnoDB数据页格式\n\n<!-- more -->\n\n页简介\n---\n\n页（page）是 InnoDB 管理存储空间的基本单位，一页大小一般为 `16KB` \n\n**页类型**\n\n- 数据页（B-Tree Node）\n- Undo页（Undo Log Page）\n- 系统页（System Page）\n- 事务数据页（Transaction System Page）\n- 等等\n\n\n\n数据页结构\n---\n\n一个 InnoDB 数据页的存储空间大概被划分为 7 个部分\n\n<img src=\"InnoDB-Page-Formats/image-20211107214720247.png\" alt=\"image-20211107214720247\" style=\"zoom: 80%;\" />\n\n- Fil Header（38 Bytes）               --头部文部           页的一些通用信息\n- Page Header（56 Bytes）              --页面头部           数据页专有的一些信息\n- Infimum + Supremum Records（26 Bytes）--最小记录和最大记录   两个虚拟的行记录\n- User Records                        --用户记录           实际存储的行记录内容\n- Free Space                          --空闲空间           页中尚未使用的空间\n- Page Directory                      --页面目录           页中的某些记录的相对位置\n- Fil Trailer（8 Bytes）               --文件尾部           校验页是否完整\n\n一个页有两个头/尾对，其中，Fil Header 与 Fil Trailer 为一对，Page Header 与 Page Directory 为另一对。前者用于定义文件，为 fil 相关程序组所关心；后者用于定义页，为 page 相关程序组所关心。\n\n> Fil 即 File\n\n夹在头尾中间的部分，即记录（records）和空闲空间（free space）。一个页面总是以两个不变的记录 Infimum 和 Supremum 开始，接下来是用户记录。在**向下增长**的用户空间与**向上增长**的 Page Directory 之间，是提供给新记录的空间空间。\n\n> 新创建的页面是不存在 User Records（用户记录）的，当插入第一条数据时，会从 Free Space 申请空间，才会出现这个部分。当 Free Space 被用完时，新插入的记录会放在新申请的数据页中。\n\n\n\n## ibd 文件\n\nWindows 下表空间数据存储在 *C:\\ProgramData\\MySQL\\MySQL Server 5.7\\Data\\\\[数据库名]\\\\[表名].ibd* 中。\n\n借助 Visual Studio Code 的 hexdump 扩展，查看该文件。\n\n当前表中数据内容如下：\n\n<img src=\"InnoDB-Page-Formats/image-20211107224411619.png\" alt=\"image-20211107224411619\" style=\"zoom:80%;\" />\n\n首先查询当前的页大小：\n\n```sql\nmysql> show status like 'Innodb_page_size';\n+------------------+-------+\n| Variable_name    | Value |\n+------------------+-------+\n| Innodb_page_size | 16384 |\n+------------------+-------+\n1 row in set (0.00 sec)\n```\n\n当前的测试环境下 InnoDB 页大小为 16 KB。因此，ibd 文件每 16 KB 属于一个页。\n\n第一个页的范围应当为 `0x0000000` ~ `0x00003ff0`。以此类推，我们把整个文件切分为多个 16 KB 部分。本文不讨论文件格式，因此直接定位到目标页，本次测试环境下是 `0x0000c000` 即第四页为测试数据存储位置。\n\n上图分析：蓝色部分为 38 字节的 Fil Header，黄色为 56 字节的 Page Header，红色为 26 字节的 Infimum + Supremum 记录。\n\n其后一部分就是数据, 绿色划线部分为 8 字节的 Fil Tailer\n\n<img src=\"InnoDB-Page-Formats/image-20211107225400407.png\" alt=\"image-20211107225400407\" style=\"zoom: 80%;\" />\n\n\n\n记录在页中的存储\n---\n\nInooDB 定义了两个伪记录分别维最小记录和最大记录（占 26 字节），都是由 `5` 字节大小的**记录头信息**和 `8` 字节大小的一个固定的部分组成，如下图\n\n<img src=\"InnoDB-Page-Formats/image-20211108124159344.png\" alt=\"image-20211108124159344\" style=\"zoom:80%;\" />\n\n在一开始生成页的时候，其实并没有 User Record 这个部分，每当我们插入一条记录，都会从 Free Space 部分申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分使用完，就要申请新的页。\n\nUser Record 中的**记录按照主键的从小到大的顺序形成一个单链表 **( next_record )\n\n<img src=\"InnoDB-Page-Formats/image-20211107204848266.png\" alt=\"image-20211107204848266\" style=\"zoom: 25%;\" />\n\n> 规定: `Infimum ` 记录的下一条记录就是本页中**主键最小**的用户记录，\n>\n> 本页中主键最大的用户记录(next_record = 0)的下一条记录就是 `Supremum` 记录\n\n不论怎么对页中的记录做增删改查操作，InnoDB **始终会维护一条记录的单链表**。\n\n> 注：当数据页中存在多条被删除的记录时，这些记录的 next_record 属性将会把这些被删除的记录组成一个**垃圾链表**，以备之后重用这个部分存储。\n\nPage Directory\n---\n\n页目录生成过程\n\n- 将所有正常记录（包括最小记录和最大记录，不包括标记删除的记录）划分为几个**组**\n- 每个组的**最后**一条记录（组内最大的那条记录）的头信息中 `n_owned` 属性表示该记录拥有多少条记录，也就是该组内有多少条记录\n- 将每组的最后一条记录的**地址偏移量**（从页面的 0 字节开始数）单独提取出来按**顺序存储到靠近页的尾部**的地方（即 Page Directory）\n\n> 页面目录中的这些**地址偏移量**被称为**槽**(Slot),所以**页目录就是由槽组成**。如下图所示\n\n<img src=\"InnoDB-Page-Formats/image-20211108144451388.png\" alt=\"image-20211108144451388\" style=\"zoom: 80%;\" />\n\n每个分组中记录条数规定:\n\n - 对于**最小记录**所在的分组只能由 `1` 条记录\n - **最大记录**所在分组拥有的记录数只能在 `1~8` 条\n - 剩下的分组记录数只能在 `4~8` 条\n\n\n\n分组步骤：\n\n 1. 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。 \n 2. 之后每插入一条记录，都会从**页目录**中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 `n_owned` 值加 `1`，表示本组内又添加了一条记录，直到该组中的记录数等于 `8` 个。 \n 3. 在一个组中的记录数等于 `8` 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 `4` 条记录，另一 个 `5` 条记录。这个过程会在页目录中新增一个**槽**来记录这个新增分组中最大的那条记录的偏移量。\n\n\n\n数据页中查找**指定主键值**的记录的过程分为两步:\n\n1. 通过**二分法**确定该记录所在的槽，并找到该槽中主键值最小的那条记录。\n2. 通过记录的 `next_record `属性遍历该槽所在的组中的各个记录。\n\nPage Header\n---\n\n> 页面头部：占有固定的 `56` 字节，专门存储各种状态信息，例如存储了多少个槽，多少条记录等等\n\n各个字节的作用如下表：\n\n| 名称              | 占用空间的大小（字节） | 描述                                                         |\n| ----------------- | :--------------------: | ------------------------------------------------------------ |\n| PAGE_N_DIR_SLOTS  |           2            | 在页目录中的槽数量                                           |\n| PAGE_HEAP_TOP     |           2            | 还未使用的空间最小地址，也就是说从该地址之后就是 Free Space  |\n| PAGE_N_HEAP       |           2            | 本页中的记录的数量(包括最小和最大记录以及标记为删除的记录)   |\n| PAGE_FREE         |           2            | 第一个已经标记为删除的记录地址(各个已删除的记录通过 next_record 也会组成一个单链 表，这个单链表中的记录可以被重新利用) |\n| PAGE_GARBAGE      |           2            | 已删除记录占用的字节数                                       |\n| PAGE_LAST_INSERT  |           2            | 最后插入记录的位置                                           |\n| PAGE_DIRECTION    |           2            | 记录插入的方向                                               |\n| PAGE_N_DIRECTION  |           2            | 一个方向连续插入的记录数量                                   |\n| PAGE_N_RECS       |           2            | 该页中记录的数量(不包括最小和最大记录以及被标记为删除的记录) |\n| PAGE_MAX_TRX_ID   |           8            | 修改当前页的最大事务 ID，该值仅在二级索引中定义              |\n| PAGE_LEVEL        |           2            | 当前页在 B+ 树中所处的层级                                   |\n| PAGE_INDEX_ID     |           8            | 索引 ID，表示当前页属于哪个索引                              |\n| PAGE_BTR_SEG_LEAF |           10           | B+ 树叶子段的头部信息，仅在 B+ 树的 Root 页定义              |\n| PAGE_BTR_SEG_TOP  |           10           | B+ 树非叶子段的头部信息，仅在 B+ 树的 Root 页定义            |\n\nFile Header\n---\n\n> 文件头部记录这页面的通用信息，例如页的编码，上一页，下一页等等，占用固定字节 `38`\n\n| 名称                             | 占用空间大小（字节） | 描述                                                         |\n| -------------------------------- | :------------------: | ------------------------------------------------------------ |\n| FIL_PAGE_SPACE_OR_CHKSUM         |          4           | 页的校验和(checksum值)                                       |\n| FIL_PAGE_OFFSET                  |          4           | 页号                                                         |\n| FIL_PAGE_PREV                    |          4           | 上一个页的页号                                               |\n| FIL_PAGE_NEXT                    |          4           | 下一个页的页号                                               |\n| FIL_PAGE_LSN                     |          8           | 页面被最后修改时对应的日志序列位置(英文名是:Log Sequence Number) |\n| FIL_PAGE_TYPE                    |          2           | 该页的类型                                                   |\n| FIL_PAGE_FILE_FLUSH_LSN          |          8           | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |\n| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID |          4           | 页属于哪个表空间                                             |\n\n> 每个数据页中的 File Header 部分上有上一个和下一个页编号，数据页会组成一个**双链表**\n\n`FIL_PAGE_OFFSET `： 每一个页都有一个单独的页号，就跟你的身份证号码一样， InnoDB 通过页号来可以**唯一定位一个页** \n\nFile Trailer\n---\n\n> File Trailer 检测一个页是否完整，由 8 个字节组成\n>\n\n这 8 个字节可以分为两个部分\n\n- 前 4 个字节代表页的校验和\n  - 这个部分适合 File Header 中的校验和相对应。\n- 后 4 个字节代表页面最后被修改时对应的日志序列位置（LSN）\n\n..\n---\n\n- 每个记录的头信息中都有一个 `next_record` 属性，从而使页中的所有记录串联成一个**单链表**\n- 每个数据页中的 File Header 部分上有上一个和下一个页编号，数据页会组成一个**双链表**\n\n","tags":["page formats"],"categories":["Mysql"]},{"title":"InnoDB Row Formats","url":"/2021/11/07/InnoDB-Row-Formats/","content":"\nInnoDB 行格式。 \n\n<!-- more -->\n\n行格式的概念 \n---\n\n**表的行格式**（Row Formats）是指行记录在磁盘上的物理存储方式。行格式会影响查询和 DML 操作的性能，随着单个磁盘页面中容纳更多行，查询（queries）和索引查找（index lookups）可以更快地进行，缓冲池中需要的缓存内存空间会更少，写入更新值所需的 I/O 也更少。 \n\n每个表中的数据被划分为**页**（pages），每个页中有一个或多个行记录。构成每个表的页面排列在称为 B+ 树索引的数据结构中。表数据（聚集索 引）和二级索引都使用这种类型的结构。\n\n\n\n> MySQL 提供了很多长度可变的数据类型，比如 `VARCHAR(M)、 VARBINARY(M)` 以及 `TEXT` 等。这些变长类型的列被称为变长字 段，其中存储的字节大小是不固定的，因此必须通过记录一些额外信息来处理这些变长字段。\n\n\n\n**变长字段**是列值存储在 B+ 树索引节点中的规则的一个例外（即变长字段 内容不一定全在 B+ 树叶子结点中）。太长而不适合 B+ 树页面的可变长度列存储在单独分配的磁盘页面上，称为**溢出页**。此类列称为**页外列**。 页外列的值存储在溢出页面的单向链接列表中，每个这样的列都有自己的 一个或多个溢出页面列表。根据列长度，可变长度列值的全部或前缀存储 在 B+ 树中，以避免浪费存储空间和读取单独的页面。\n\n\n\nInnoDB 支持四种行格式，特性各不相同：\n\n- REDUNDANT \n- COMPACT \n- DYNAMIC \n- COMPRESSED\n\n\n\n|    行格式    | 紧凑的存储特性 | 增强的可变长度列存储 | 大索引键前缀 支持 | 压缩支 持 |        支持的表空间类型         |     所需文件格式      |\n| :----------: | :------------: | :------------------: | :---------------: | :-------: | :-----------------------------: | :-------------------: |\n| `REDUNDANT`  |       No       |          No          |        No         |    No     | system, file-per-table, general | Antelope or Barracuda |\n|  `COMPACT`   |      Yes       |          No          |        No         |    No     | system, file-per-table, general | Antelope or Barracuda |\n|  `DYNAMIC`   |      Yes       |         Yes          |        Yes        |    No     | system, file-per-table, general |       Barracuda       |\n| `COMPRESSED` |      Yes       |         Yes          |        Yes        |    Yes    |     file-per-table, general     |       Barracuda       |\n\n\n\n变量 `innodb_default_row_format `定义了默认使用的格式（默认为 DYNAMIC），而在建表（CREATE）或修改表（ALTER）时，也可以使用 ROW_FORMAT 选项自定义。\n\nCOMPACT\n---\n\nCOMPACT 行格式的结构如下图\n\n<img src=\"InnoDB-Row-Formats/compact-1.png\" />\n\n其中，**变长字段长度列表**、NULL 值列表和记录头信息属于数据之外的额外信息。 \n\n### 变长字段长度列表\n\n**变长字段长度列表**顾名思义，存储的是变长字段的长度，它按照逆序存储 变长列的字节数。例如行中有三列（均为变长类型），从左到右为 c1、 c2、c3，长度分别为 1 字节、2 字节、4字节，那么变长字段长度列表 中存储的就是 0x040201。 \n\n当然这里有一个问题，那就是如果变长字段的长度 1 字节存不下怎么办。 InnoDB 按照一定的规则去处理这些情况。 \n\n对于不同的编码方式，相同字符占用的空间不一定相同，事先约定，某字符集单个字符占用的最大字节数为 MaxLen，例如 UTF-8 编码的 `MaxLen `就是 3 (**这是mysql特有的，真实的utf-8编码长度为1~4字节**)。对于变长类型来说，它们一般是限制字符数量而不是字节数量，因此，VARCHAR(M) 最多能够存储 M 个字符，即 ` M * MaxLen` 个字节。这里假设实际存储的字符串的字节数为 Length。有了 这三个变量，可以设定以下规则。 \n\n- 当 `M * MaxLen = 255`，使用 `1` 字节来存储变长字段长度。\n- 当 `M * MaxLen > 255`，分情况讨论： \n  - `Length = 127`，使用 `1` 字节来存储变长字段长度。 \n  - `Length > 127`，使用 `2 `字节来存储变长字段长度。\n\n#### 特例\n\n1. 变长字段长度列表**不存储值为 NULL 的长度信息**，会在 NULL 的标志位存储；\n2. 变长字段长度列表**不一定能存在**,例如\n   - 表中无变长字段\n   - 变长字段值为 NULL\n3. 变长字段长度列表**各字段的长度信息逆序存储**\n4. char类型字段的长度信息是否需要存储在 变长字段的长度列表 中取决于其所使用的**字符集是否为变长字符集**\n   - MySQL中 `char(M)` 类型的字段表示该字段最多可以存储 **M 个字符**。\n   - 对于定长字符集(如 ascii 字符集)而言，compact 行格式下存储该字段所占有的空间固定为 `M x Maxlen` 个字节。\n   - 但是对于变长字符集而言情况就大不一样了，例如 utf8 字符集，其存储 `M ` 个字符所需的空间为 `M~3M` 个字节。\n   - 在compact行格式下，char类型字段会由于使用变长字符集而导致其所占的**字节数(即长度信息)不定**，故此时 char 类型的数据同样也需要在变长字段的长度列表中存储其长度信息\n\n\n\n\n### NULL值列表\n\n- 二进制位的值为 1 时，代表该列的值为 NULL\n- 二进制位的值为 0 时，代表该列的值不为 NULL\n- MySQL 规定 NULL 值列表必须用整数个字节的位表示\n- 不一定每列都存在 NULL 值标志\n\n\n\n### 记录头信息\n\n![note_info](InnoDB-Row-Formats/note_info.png)\n\n固定为 `5` 个字节\n\n- **预留位1、2**【2 bit】：暂未使用\n- **delete_mask**【1 bit】：当前记录被删除的标志位\n- **min_rec_mask**【1 bit】：B+树的每层非叶子节点中的最小记录的标志位\n- **n_owned**【4 bit】：当前记录拥有的记录数\n- **heap_no**【13 bit】：当前记录在记录堆中的位置\n- **record_type**【3 bit】：当前记录类型。具体地，0: 普通记录；1:  B+ 树非叶子节点记录（即所谓的目录项记录）；2: 最小记录；3: 最大记录\n- **next_record**【16 bit】：下一条记录的相对位置\n\n> next_record 指针指向**记录头信息和真实数据之间的位置**,后面的页格式会用到\n\n### 记录真实数据\n\n1. 隐藏列【19字节】\n\n- **DB_ROW_ID**：该字段占 6 个字节，用于标识一条记录，【不一定存在，只有在用户没有定义主键时，且没有唯一且不为 NULL 的列】\n- **DB_TRX_ID**：该字段占 6 个字节，其值为事务 ID\n- **DB_ROLL_PTR**：该字段占 7 个字节，其值为回滚指针\n\n2. 真实列 1，2，3，4\n\n### 实例分析\n\n#### 建表并插入数据\n\n```sql\nDROP TABLE IF EXISTS `demo1`;\nCREATE TABLE `demo1`  (\n  `test1` varchar(10),\n  `test2` varchar(10),\n  `test3` char(10),\n  `test4` varchar(10)\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = COMPACT;\n\nINSERT INTO `demo1` VALUES ('a', 'bb', 'ccc', 'dddd');\nINSERT INTO `demo1` VALUES ('e', 'ff', NULL, 'hhhh');\nINSERT INTO `demo1` VALUES ('e', NULL, 'ggg', 'hhhh');\n```\n\n#### 找到数据所在位置（ idb 文件）\n\n![compact-analyze](InnoDB-Row-Formats/compact-analyze.png)\n\n#### 分析\n\n只分析第一行数据\n\n**红色的部分** 为 变长字段长度列表，04 0A 02 01 转为十进制是 `4 10 2 1`, 因为是逆序存储, 所以变长字段的长度应该为`1 2 10 4` 正好对应'a'[varchar], 'bb'[varchar], 'ccc'[char(10)], 'dddd'[varchar]，至于为什么定长 char 类型也存在其中（请看特例的第四点）这里不再解释。\n\n**绿色的部分** 为 NULL 值标志位，`00` 代表没有空值\n\n**黄色的部分** 为固定 5 字节大小的记录头信息，`00 00 10 00 2D`\n\n![compact-analyze](InnoDB-Row-Formats/compact-analyze-2.png)\n\n\n\nREDUNDANT\n---\n\n`REDUNDANT` 格式是 MySQL 5.0 之前的版本使用的行记录格式，其后版本提供该格式是为了向后兼容（兼容旧版本）。 \n\n\n\n> REDUNDANT 格式是非常原始的行格式，目前已经很少使用了，其**占用空间最多，内存碎片化最严重，性能较差**。\n\n\n\nREDUNDANT 的格式如下图。\n\n<img src=\"InnoDB-Row-Formats/redundant.png\" alt=\"redundant\"  />\n\n\n\n> ***Redundant*** 是 MySQL 5.0 之前的行结构，于 Compact 的主要区别是字段偏移量长度、 NULL 值列表等\n\n\n\n### 字段长度偏移列表\n\n> 包含了所有列（包括隐藏列）的长度信息，它是首先计算各列的长度信息，然后依次累加，最后逆序存储。\n\n字段长度偏移列表中每个偏移量所占字节要么全是1字节或者 2 字节。\n\n- 当记录数据内容的整个部分数据（包括隐藏列）所占空间小于 `127` 字节,则各偏移量只需要 `1` 个字节\n- 当其所占空间超过 `127` 字节但是小于`32767`字节，则各偏移量需要 `2` 字节\n  - 该记录会通过**记录头信息**的 **1byte_offs_flag** 属性来表明该记录各偏移量的字节数，以便读取记录的时候方便解析\n\n注意：\n\n- 字段长度偏移列表包含 NULL 值标志\n  - 偏移量的第一位实际上是没有使用的，其用于标识该记录下相应列是否为 NULL 值，如果是 NULL 值，则该位为 1；反之，则为 0\n\n### 记录头信息\n\n> 记录头信息用于描述该条记录，其固定为 6 个字节，即 48 位\n\n![note_info2](InnoDB-Row-Formats/note_info2.png)\n\n- **预留位1、2**：暂未使用\n- **delete_mask**【1 bit】：当前记录被删除的标志位\n- **min_rec_mask**【1 bit】：B+ 树的每层非叶子节点中的最小记录的标志位\n- **n_owned**【4 bit】：当前记录拥有的记录数\n- **heap_no**【13 bit】：当前记录在记录堆中的位置\n- **n_field**【10 bit】：表示记录中**列的数量**\n- **1byte_offs_flag**【1 bit】：**标识字段长度偏移列表中各列的偏移量使用的字节数。0：意为每个偏移量均使用 2 个字节表示；1：意为每个偏移量均使用 1 个字节表示**\n- **next_record**【16 bit】：下一条记录的相对位置\n\n\n\n行溢出\n---\n\n众所周知，InnoDB 存储引擎中内存与硬盘交互的基本单位是页，一般地页大小为`16KB`。MySQL 规定一个页中至少需要存放两条记录。\n\n而所谓的**行溢出**是指：当某个记录的某个字段(varchar、text、blob等类型)的值长度过长、数据量过大，会导致一个页中放不下一条记录，为此在compact、redundant行格式中，如果该记录某字段中数据量过多时，则在该记录的数据内容的相应字段处只存储该字段值**前768个字节**的数据和一个指向存储剩余数据的其他页（即所谓的**溢出页**）的**地址**，该地址通常占用**20个字节**\n\n> 通俗的说就是如果数据量过多，数据内容部分只存 **768个前缀字节** 和 **20字节的指针**（指的是 REDUNDANT 和 COMPACT）\n\n  \n\nCOMPRESSED 和 DYNAMIC 行记录格式\n---\n\nInnodb 1.0 之后引入新的文件格式（file format,可以理解为新的页格式）。\n\n> 以前支持 COMPACT 和 REDUNDANT 格式称为 `Antelop` 文件格式，新的文件格式称为`Barracuda`文件格式（包含了两种新的行记录格式：COMPRESSED 和 DYNAMIC)。\n\n新的两种记录格式对于存放 `BLOB ` 中的数据采用了**完全行溢出**方式(数据页中只存放 **20 字节的指针**，实际数据都存放在 `Off Page`)\n\n![off-page](InnoDB-Row-Formats/off-page.png)\n\nCompressed行记录格式的另一个功能，存储在其中的数据会以 `zlib` 的算法进行压缩（对 BLOB、TEXT、VARCHAR 这种特别有用）\n\n\n\n### DYNAMIC\n\n**DYNAMIC**行格式提供了与**COMPACT**行格式相同的存储特性，但为变长字段长度列添加了增强的存储功能，并支持大索引键前缀。\n\n\n\n当使用 ROW_FORMAT=`DYNAMIC`创建表，InnoDB 可以存储`fully off-page`的变长字段长度列值（用于 VARCHAR、VARBINARY、BLOB 和 TEXT 类型），聚集索引记录只包含指向**溢出页面的20字节指针**。大于或等于`768`字节的固定长度字段被编码为可变长度字段。例如，如果字符集的最大字节长度大于3，则 char(255） 列可能超过768字节， utf8mb4 就是如此。\n\n\n\n> 列是否在页外存储取决于页面大小和行的总大小。当一行太长时，会选择最长的列进行页外存储，直到聚集索引记录适合 B+ 树页面。小于或等于40字节的 [`TEXT`](https://dev.mysql.com/doc/refman/5.7/en/blob.html) and `BLOB` 列存储在行中。\n\n\n\n`DYNAMIC`行格式保持了在索引节点中存储整行的效率（`COMPACT` 和`REDUNDANT` 格式也是如此），但`DYNAMIC`行格式避免了用大量长列数据字节填充 B+ 树节点的问题。\n\n`DYNAMIC`行格式基于这样的思想：如果长数据值的一部分存储在页外，则通常最有效的方法是在**页外存储整个值**。使用 DYNAMIC 格式，较短的列可能保留在 B+ 树节点中，从而最大限度地减少给定行所需的溢出页数。\n\n\n\n>DYNAMIC 行格式支持最多`3072`字节的索引键前缀。此功能由`innodb_large_prefix`变量控制，该变量在默认情况下处于启用状态。\n\n\n\n### COMPRESSED\n\n`COMPRESSED`行格式提供了与`DYNAMIC`行格式相同的存储特性和功能，但增加了对**表和索引数据压缩**的支持\n\n\n\n`COMPRESSED`行格式使用与`DYNAMIC`行格式类似的页外存储内部详细信息，并从压缩的表和索引数据中考虑额外的存储和性能，使用较小的页面大小。对于压缩行格式，`KEY_BLOCK_SIZE`选项控制在聚集索引中存储多少列数据，以及在溢出页上存储多少列数据。\n\n\n\n>COMPRESSED行格式支持最多`3072`字节的索引键前缀。此功能由`innodb_large_prefix`变量控制，该变量在默认情况下处于启用状态。\n\n\n\n使用`COMPRESSED`行格式的表可以在每个表的**文件表空间**或**常规表空间**中创建。**系统表空间不支持压缩行格式**。要在每个表空间的文件中存储压缩表，必须启用`innodb_file_per_table`变量，并且必须将`innodb_file_format`设置为`Barracuda`。innodb_file_per_表和innodb_file_格式变量不适用于常规表空间。通用表空间支持所有行格式，但需要注意的是，**由于物理页大小不同，压缩表和未压缩表不能在同一个通用表空间中共存**。\n\n\n\n总结\n---\n\n### Antelop 文件格式\n\n#### Redundant\n\n- 记录额外信息\n  - 字段偏移长度列表\n  - 记录头信息\n- 记录真实信息（包含隐藏列）\n\n这种行格式存储已经**基本不使用**了，占用空间最多，内存碎片化最严重，性能较差\n\n#### COMPACT\n\n- 记录额外信息\n\n  - 变长字段长度列表\n\n  - NULL 值列表\n\n  - 记录头信息\n\n- 记录真实数据（包含隐藏列）\n\n\n\n### Barracuda 文件格式\n\n加入了 DYNAMIC 和 COMPRESSED 新的行格式存储\n\n#### Dynamic 和 Compressed\n\n- 类似 Compact 行格式，只不过在存储数据发生溢出时的处理方式不一样，Dynamic 是在记录真实数据哪里只存储20字节的页地址，所有字节都存到其他页面中。\n- Compressed 行格式会采取压缩算法对页面进行压缩\n\n","tags":["row formats"],"categories":["Mysql"]},{"title":"ubuntu配置","url":"/2021/10/31/ubuntu配置/","content":"\nubuntu配置\n\n<!-- more -->\n\n换源\n---\n\n> 文件位置/etc/apt/sources.list\n\n1. 备份\n\n```shell\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.backup\n```\n\n2. 打开sources.list文件\n\n```shell\nsudo vim /etc/apt/sources.list\n```\n\n3. 删除原来内容，替换为以下内容\n\n```tex\n#阿里云镜像\n\ndeb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n```\n\n4. 更新\n\n```shell\nsudo apt update\nsudo apt upgrade\n```\n\n\n\n取消sudo密码\n---\n\n> 文件位置 /etc/sudoers\n\n1. 打开文件\n\n```shell\nsudo vim /etc/sudoers\n```\n\n2. 添加如下内容\n\n```shell\n#includedir /etc/sudoers.d\nadmin ALL=(ALL)  NOPASSWD:ALL\nyou_name ALL=(ALL) NOPASSWD:ALL\n```\n\n3. 强制退出，wq!\n\n\n\n更换主题\n---\n\n以zsh主题为例\n\n1. 查看当前有什么主题\n\n```shell\ncat /etc/shells\n```\n\n2. 安装zsh\n\n```shell\nsudo apt install zsh\n```\n\n3. 更换当前主题\n\n```shell\nchsh -s /bin/zsh\n```\n\n4. 安装git\n\n```shell\nsudo apt install git\n```\n\n5. 安装oh-my-zsh\n\n```shell\nsh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\"\n```\n\n6. 更换自己喜欢的主题\n\n```shell\nsudo vim ~/.zshrc\n#更改 ZSH_THEME=\"robbyrussell\"\nZSH_THEME=\"ys\"\n```\n\n","tags":["ubuntu"],"categories":["ubuntu"]},{"title":"Windows10更新问题","url":"/2021/06/24/Windows10更新问题/","content":"\nwindows10更新问题,抱歉，我们很难确定你的电脑能否运行Windows 10，请关闭安装程序，然后再试一次;\n\n<!-- more -->\n\nwindows10更新问题\n---\n\n### 问题描述：\n\n1、在设置中进行质量或其他更新，重启后在更新配置到99%是，提示无法更新，然后撤销更改；\n\n2、使用易升或更新程序（MediaCreationTool****.exe）更新，提示：“抱歉，我们很难确定你的电脑能否运行Windows 10，请关闭安装程序，然后再试一次。”；如下图。\n\n<img src=\"Windows10更新问题/问题截图.jpg\" alt=\"问题截图\" style=\"zoom:50%;\" />\n\n### 解决方法：\n\n（不一定能解决，只适用特定情况）\n\n1、将C盘空余出40G以上的可用空间（有时20G都不够原因是系统要保留原有系统备份、解压等）\n\n2、win+R 输入msconfig 按回车，选择引导，正常的如下图\n\n<img src=\"Windows10更新问题/windows10-2.png\" alt=\"windows10-2\" style=\"zoom:50%;\" />\n\n如果为空白，会报不能此电脑是否运行的系统，是因为运行msconfig，在引导页中是空白的，看不到引导的系统（但是电脑是正常可以开机的）；造成的原因可能是你最近装过双系统。\n\n3、修复引导，需要一个PE系统的U盘。（网上有很多PE的制作教程）\n\n4、进入PE系统，打开DiskGenius，如下图\n\n![windows10-3](Windows10更新问题/windows10-3.png)\n\n你的可能名字不叫ESP，可能叫分区0或其他的名称，使用DiskGenius指定盘符为x或其它可用盘符。\n\n查看你的分区类型\n\n![windows10-4](Windows10更新问题/windows10-4.png)\n\n我的是GPT，你的可能是MBR\n\n5、打开PE系统的Windows10引导修复软件\n\na、GPT：选择 uefi  ，选择挂载地方（x盘，刚刚指定的盘符）点击修复\n\n注：以上操作仅在我自己出问题的笔记本上操作有效，注意备份数据。\n","tags":["windows10","windows10更新问题"],"categories":["windows10"]}]