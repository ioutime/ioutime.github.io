[{"title":"编码格式","url":"/2021/11/04/编码格式/","content":"\n编码格式\n\n<!-- more -->\n\n 基本知识：\n\n - 计算机中最小单元为 **一个字节** 【1 byte = 8 bit】 0~(2^8 - 1)\n\n\n\n字符集\n---\n\n 定义：多个字符的集合； \n\n 常见的字符集：\n\n 1. **ASCII字符集**\n 2. **GB2312字符集**\n 3. BIG5字符集\n 4. **GB18030字符集**\n 5. **Unicode字符集**\n\n\n\n### 字符集发展过程\n\n1. ASCII码 【美国，英文字母、标点符号、阿拉伯数字】\n2. Latin-1 【欧洲，加入希腊字母】\n3. GB2312  【中国，加入汉字】\n4. GBK     【加入生僻字，繁体字和日韩汉字】\n5. Unicode 【ISO国际标准化组织一统江湖】\n6. UTF-8   【再编码】\n\n\nASCII码字符集\n---\n\n全称：美国信息交换标准码，**实现方式与字符集同名**\n\n - 只用了一个字节的后 **`7`** bit【第一位`0`】，所以只有 `128` 种字符【`32`个不可打印字符】\n - 二进制表示\n\n\n\nGB2312字符集\n---\n\n **实现方式与字符集同名**\n\n - 分区表示: GB2312中对所收汉字进行了“分区”处理，每区含有94个汉字/符号。这种表示方式也称为区位码\n - 双字节表示: 两个字节中前面的字节为第一字节，后面的字节为第二字节。习惯上称第一字节为`高字节` ，而称第二字节为`低字节`。\n\n\n\nGBK字符集\n---\n\n **实现方式与字符集同名**\n\n - 是GB2312的扩展\n - 向上兼容，使用GB2312编码的可以使用GBK解码\n\n\n\n**Unicode字符集**\n---\n\n 全称： 统一的字符编码标准\n\n - Unicode 只是一个符号集，它只规定了**符号对应的二进制代码**，却没有规定这个二进制代码应该如何存储。\n\n - Unicode是一本字典，他不是一次性定义的，是**分区定义**的，每个区可以存　`2＾16` 字符【`65536`】,把它称之为一个**平面**（plane)\n\n   目前有`2^5` 平面【`17`】\n\n   - BMP【基本平面】：`0 ~ 2^16 - 1` ，（U+0000 到 U+FFFF）\n   - SMP【辅助平面】：剩下的字符，（U+010000 到 U+10FFFF）\n\n - Unicode 有多种实现方式：\n\n   - UTF-8 【变长 1 ~ 4 字节】\n   - UTF-16 【两个 或 四个 字节】\n   - UTF-32  【四个字节】\n\n\n\n### **UTF-8**\n\n全称：Unicode 转换格式 8-bit \n\n- **utf8是 Unicode 的一种实现方式**\n- utf-8是一种**变长的编码方式**，使用 **`1` ~ `4`** 个字节表示一个字符\n - 如果一个字节的第一位是`0`，则这个字节单独就是一个字符；如果第一位是`1`，则连续有多少个`1`，就表示当前字符占用多少个字节\n\n\n\n### UTF-16\n\n- 基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节\n- 当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。\n\n\n\n### UTF-32\n\n **四个字节**实现Unicode\n\n\n\n总结\n---\n\n| 主要字符集 |   字符集实现方式    |                             备注                             |\n| :--------: | :-----------------: | :----------------------------------------------------------: |\n|   ASCII    |        ASCII        | 美国定义的，主要包含英文字母、数字等,128个字符【第一位没用】，32个不可打印字符 |\n|   GB2312   |       GB2312        |                      中国定义，加入汉字                      |\n|    GBK     |         GBK         |                          兼容GB2312                          |\n|  Unicode   | UTF-8/UTF-16/UTF-32 |        UTF-8变长【1~4】、UTF-16【2或4】、UTF-32【4】         |\n","tags":["计算机"],"categories":["计算机"]},{"title":"ubuntu配置","url":"/2021/10/31/ubuntu配置/","content":"\nubuntu配置\n\n<!-- more -->\n\n换源\n---\n\n> 文件位置/etc/apt/sources.list\n\n1. 备份\n\n```shell\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.backup\n```\n\n2. 打开sources.list文件\n\n```shell\nsudo vim /etc/apt/sources.list\n```\n\n3. 删除原来内容，替换为以下内容\n\n```tex\n#阿里云镜像\n\ndeb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse \ndeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse \ndeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n```\n\n4. 更新\n\n```shell\nsudo apt update\nsudo apt upgrade\n```\n\n\n\n取消sudo密码\n---\n\n> 文件位置 /etc/sudoers\n\n1. 打开文件\n\n```shell\nsudo vim /etc/sudoers\n```\n\n2. 添加如下内容\n\n```shell\n#includedir /etc/sudoers.d\nadmin ALL=(ALL)  NOPASSWD:ALL\nyou_name ALL=(ALL) NOPASSWD:ALL\n```\n\n3. 强制退出，wq!\n\n\n\n更换主题\n---\n\n以zsh主题为例\n\n1. 查看当前有什么主题\n\n```shell\ncat /etc/shells\n```\n\n2. 安装zsh\n\n```shell\nsudo apt install zsh\n```\n\n3. 更换当前主题\n\n```shell\nchsh -s /bin/zsh\n```\n\n4. 安装git\n\n```shell\nsudo apt install git\n```\n\n5. 安装oh-my-zsh\n\n```shell\nsh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\"\n```\n\n6. 更换自己喜欢的主题\n\n```shell\nsudo vim ~/.zshrc\n#更改 ZSH_THEME=\"robbyrussell\"\nZSH_THEME=\"ys\"\n```\n\n","tags":["ubuntu"],"categories":["ubuntu"]},{"title":"Java中的集合问题","url":"/2021/06/28/Java中的集合问题/","content":"\n 一些集合总结\n\n<!-- more -->\n\n集合\n---\n\n\n\n### List 、Set、Map\n\n- List：有序（存取元素有序）\n- Set：无序，不重复\n- Map：键值对，key不能重复\n\n\n\n### ArrayList 、LinkedList\n\n- 底层实现：ArrayList 是数组；LinkedLsit是链表\n- 对于index索引数据：ArrayList 直接定位；LinkedList则需要遍历\n- 对于随机插入和删除：ArrayList需要移动目标的后面节点；LinkedList则只需要修改前后节点的属性\n- 对于顺序插入和删除：ArrayList不需要移动节点；比LinkedList效率上高\n\n总结：需要有大量的插入和删除操作，选择LinkedList；需要很多查找操作，插入和删除操作较少，则选择ArrayList\n\n\n\n### ArrayList 、Vector\n\nVector在方法上加了synchronized来确保线程安全，其他多差不多\n\n\n\n### HashMap的底层数据结构\n\n在 jdk 1.8 之前都是“数组+链表”，在 jdk 1.8之后都是\"数组+链表+红黑树\"；\n\n```java\n//负载因子\nDEFAULT_LOAD_FACTOR = 0.75f\n```\n\n\n\n#### 为什么改成\"数组+链表+红黑树\"\n\n主要为了解决hash冲突严重时（链表过长）的查找性能，使用链表的查找性能O(n)，使用红黑树的查找性能时O(log n)\n\n\n\n#### 什么时候用链表，什么时候用红黑树\n\n```java\n//阈值\nTREEIFY_THRESHOLD = 8;\nUNTREEIFY_THRESHOLD = 6;\n//时间和空间的权衡\n```\n\n\n\n#### threshold用途\n\n存放扩容阈值；（容量 * 负载因子）\n\n\n\n#### HashMap容量\n\n```java\nDEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n//最小容量为2的N次方\n```\n\n#### HashMap计算hashCode方法\n\n```java\nreturn (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n//^是异或\n```\n\n当数组的长度很短时，只有低位数的hashcode值能参与运算。而让高16位参与运算可以更好的均匀散列，减少碰撞，进一步降低hash冲突的几率。并且使得高16位和低16位的信息都被保留了\n\n#### jdk 1.8之前为什么会出现死循环\n\njdk 1.7 扩容采用的是\"头插法\"，会导致同一个索引位置的节点在扩容后顺序反掉。jkd 1.8采用的是“尾插法”\n\n### HashMap 和 Hashtable\n\n1. Hashtable是线程安全，它在方法上都加了synchronized来保证线程安全；HashMap不是线程安全\n2. Hashtable的初始容量是11；HashMap的初始容量为16；\n3. Hashtable的扩容为2的N倍 + 1；HashMap的容量始终问2 的指数\n4. Hashtable继承的类是Dictionary；HashMap继承的是AbstractMap\n5. Hashtable是创建时就初始化；HashMap是第一次put时初始化\n6. Hashtable的key和value不允许为空；HashMap可以\n7. Hashtable的hash值是key.hashCode()算出来的；HashMap的hash是重新计算过的\n8. HashMap去掉了 Hashtable 中的contains方法\n\n\n\n### ConcurrentHashMap \n\n数据结构：jdk 1.7 采用 分段的数组 + 链表；jdk 1.8 采用 数组 + 链表 + 红黑树\n\n线程安全：jdk 1.7 采用分段锁 ；jdk 1.8 采用synchronized + CAS (比较并交换)\n\n\n\n###  Comparable 和 Comparator\n\nComparable是自然排序接口；Comparator是比较排序器\n\n\n\n### Collection 和 Collections\n\nCollection是集合类的一个顶级接口；\n\nCollections是集合类的一个工具类/帮助类，提供一系列静态方法\n\n","tags":["Java集合"],"categories":["Java"]},{"title":"JVM垃圾回收机制(GC)","url":"/2021/06/27/JVM垃圾回收机制-GC/","content":"\nJVM垃圾回收机制(GC)\n\n<!-- more -->\n\n垃圾回收器\n---\n\n### 判断对象是否已死\n\n- **引用计数算法**：在对象中添加一个引用计数器，在被引用的时候就加一，当引用失效时，就减一；当引用计数器为0时就是代表该对象不会在被引用。缺点：无法解决对象之间的相互引用问题。\n\n- **可达性分析算法**：从根节点集合\"GC Root Set\" 开始，根据引用关系向下搜索，搜索过程的路径称为\"引用链\"，无法到达的就意味着是垃圾。\n\n  \n\n固定可作为GC Roots的对象包括：\n\n1. 栈帧中的本地变量表中引用的对象；\n2. 方法区中类静态属性引用的对象；\n3. 方法区中常量引用的对象；\n4. 本地方法栈中JNI引用的对象；\n5. Java虚拟机内部的引用；\n6. 所有被同步锁（synchronized）持有的对象；\n7. 反应Java虚拟机内部情况JMXBean、JVMTI中注册的回调、本地代码缓存等。\n\n\n\n### 引用（reference）\n\n- 强引用：普遍存在的引用赋值，只要引用关系还在，GC 永远不会回收被引用的对象,eg:\" Object obj = new Object( )  \"；\n- 软引用：一些有用，但非必须的对象，会在内存溢出之前，被列入第二次回收对象列中；\n- 弱引用：描述那些非必须的对象，强度比软引用更弱一点，只能存活到下一次垃圾收集发生之前；\n- 虚引用：最弱的一种引用关系，为对象设置该引用唯一目的是为了在这个对象被GC回收时收到一个系统通知。 虚引用必须和引用队列（ReferenceQueue）联合使用\n\n\n\n### 堆内存常见的分配策略\n\n- 对象优先进入Eden区分配\n  - 当Eden内存几乎被分配完全了，如果此时再为其他的对象分配内存，虚拟机就会发起一次Minor GC,如果之前的对象无法存入幸存区，只能通过**分配担保机制**将新生代的对象提前转移到老年代中\n- 大对象直接进入老年代\n  - 为什么要这样——为了避免大对象分配内存由于分配担保机制带来的复制导致降低效率\n- 长期存活的对象进入老年代\n  - 虚拟机给每个对象一个对象年龄(Age) 计数器\n\n\n\n### 生存后死亡\n\n即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\n\n被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\n\n\n\n### 如何判断一个常量是废弃常量\n\n运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢?\n\n假如在常量池中存在字符串\"abc\" ,如果当前没有任何String对象引用该字符串常量的话，就说明常量\"abc\"就是废弃常量,如果这时发生内存回收的话而且有必要的话，\" abc\"就会被系统清理出常量池。\n\n### 如何判断一个类是无用的类\n\n方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\n\n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：\n\n- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n- 加载该类的 `ClassLoader` 已经被回收。\n- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。\n\n### 垃圾收集算法\n\n#### 分代收集理论\n\n分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。\n\n- 部分收集（Partial GC）\n  - 新生代收集（Minor GC/Young GC）\n  - 老年代收集（Major GC/Old GC）\n  - 混合收集（Mixed GC）\t\t\n\n- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集\n\n#### 标记-清除算法\n\n标记阶段是把所有活动对象（可达对象，reachable）都做上标记的阶段。 清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段。\n\n缺点：\n\n- 执行效率不稳定\n- 内存空间碎片化问题\n\n\n\n#### 标记-复制算法\n\n它将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。\n\n缺点：\n\n- 内存缩小一半，空间浪费太多\n\n\n\n#### 标记-整理算法\n\n该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存\n\n\n\n### 垃圾收集器\n\n![2021-7-16 1-0](JVM垃圾回收机制-GC/2021-7-161-0.png)\n\n![2021-7-16 1-1](JVM垃圾回收机制-GC/2021-7-161-1.png)\n","tags":["Java","JVM"],"categories":["Java"]},{"title":"JVM类加载机制","url":"/2021/06/27/JVM类加载机制/","content":"\nJVM类加载机制\n\n<!-- more -->\n\n类加载机制\n---\n\n### 类的加载时机（触发条件）\n\n- 使用new关键字实例化对象\n- 读取或设置一个类型的静态字段\n- 调用一个类型的静态方法的时候\n- 反射（使用java.lang.reflect包的方法对类型进行反射调用）\n- 初始化一个类的子类（会首先初始子类的父类）\n- JVM启动标明的启动类，即文件名和类名相同的那个类\n\n### 类的加载过程\n\n- 加载 (Loading)\n- 验证(Verification)\n- 准备(Preparation)\n- 解析(Resoultion)\n- 初始化(Initialization)\n- 使用(Using)\n- 卸载(UnLoading)\n\n注意：静态变量在准备阶段只进行创建；静态常量在准备阶段就会进行初始化\n\n### 类的加载器(ClassLoader)\n\n- 启动类加载器( Bootstrap )：加载存放在lib目录下的jar包、或被-Xbootclasspath参数指定指向的路径中存放的jar包\n- 扩展类加载器( Extension )：加载lib\\ext下的jar包\n- 应用程序类加载器( Application )：加载用户类路径（ClassPath）上所有类库\n- 自定义类加载器( Custom )：继承classLoader，重写findClass方法\n\n\n\n### 双亲委派模型\n\n简单的来说，类加载器永远要先请示上级，上级会请示它的上级，除非所有上级都做不了，这件事才轮到你来\n\n加载过程\n\n![ClassLoader](JVM类加载机制/ClassLoader.png)\n\n**不可重写String类**\n","tags":["Java","JVM"],"categories":["Java"]},{"title":"JVM内存结构","url":"/2021/06/27/Java内存区域/","content":"\n内存结构\n\n<!-- more -->\n\nJVM内存结构\n---\n\n### JVM 运行时内存结构图\n\n![JVM-1](Java内存区域/JVM-1.png)\n\n所有线程共享：\n\n- 方法区（Method Area)：也叫元空间，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存的数据【**运行时的常量池也是方法区的一部分**】\n\n  ![method-1](Java内存区域/method-1.png)\n\n- 堆区（Heap Area）：占的最大，存放Java**对象的实例**\n\n线程私有（线程独立）：\n\n- 栈区（Stack Area)：每个方法被执行的时候，都会同步创建一个**栈帧**（Stack Frame）用于存储**局部变量表、操作数栈**、动态连接、方法出口等\n\n  ![Stack-1](Java内存区域/Stack-1.png)\n\n- 程序计数器（Program Counter Register）：一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器\n\n- 本地方法栈（Native Method Area）：调用本地方法，和栈区通过本地方法接口（JNI）通信\n\n\n\n### 堆区（Heap Area)\n\n- 新生代（Young）：又分伊甸区（Eden)、两个幸存区（From Survivor, To  Survivor)\n- 老年代（Old）：\n\n![Heap-1](Java内存区域/Heap-1.png)\n","tags":["Java","JVM"],"categories":["Java"]},{"title":"Java实现栈","url":"/2021/06/24/Java实现栈/","content":"\n栈\n\n<!-- more -->\n\n实现栈的两种方法\n---\n\n### 数组：\n\n#### 代码：\n\n```java\n/**\n * @author ioutime\n * @version 1.0\n * @date 2021/6/24 15:26\n */\n\n//数组实现\npublic class MyStack{\n    private int[] elem;\n    private int top;\n    private int bottom;\n    private int usedSize;\n\n    public MyStack(){\n        this.elem = new int[10];\n    }\n\n    //print\n    public void print(){\n        for (int i = 0; i < usedSize; i++) {\n            System.out.print(elem[i]+\" \");\n        }\n        System.out.println();\n    }\n\n\n    //扩容\n    public void addSize(){\n        this.elem = Arrays.copyOf(this.elem, this.elem.length * 2);\n    }\n\n    //判断是否满了\n    public boolean isFull(){\n        return this.elem.length==usedSize;\n    }\n\n    //push\n    public void push(int val){\n        if(isFull()){\n            addSize();\n        }\n        this.elem[usedSize] = val;\n        this.usedSize++;\n        this.top++;\n    }\n\n    //pop\n    public int pop(){\n        if(this.top < this.bottom) return -1;\n        this.top = this.top - 1;\n        this.usedSize = this.usedSize - 1;\n        return this.elem[this.usedSize];\n    }\n\n    //peek\n    public int peek(){\n        return this.elem[this.usedSize - 1];\n    }\n\n}\n```\n\n#### 测试：\n\n```java\n/**\n * @author ioutime\n * @version 1.0\n * @date 2021/6/24 16:00\n */\n\npublic class Main {\n    public static void main(String[] args) {\n        MyStack stack = new MyStack();\n        stack.push(89);\n        stack.push(90);\n        stack.push(91);\n        stack.print();\n        System.out.println(stack.pop());\n        stack.print();\n        System.out.println(stack.peek());\n        stack.print();\n    }\n}\n```\n\n测试结果：\n\n```java\n89 90 91 \n91\n89 90 \n90\n89 90 \n```\n\n### 链表：\n\n注：我直接使用java中类去实现的\n\n#### 代码\n\n```java\nDeque<Integer> stack = new LinkedList<>();\n//不建议直接使用Stack类，它属于进程安全类\n```\n\n#### 测试：\n\n```java\npublic class MyStack2 {\n    public static void main(String[] args) {\n        Deque<Integer> stack = new LinkedList<>();\n        stack.push(34);\n        stack.push(56);\n        stack.push(89);\n        System.out.println(stack.pop());\n        System.out.println(stack.peek());\n    }\n}\n```\n\n#### 结果：\n\n```java\n89\n56\n```\n\n","tags":["栈"],"categories":["数据结构"]},{"title":"Windows10更新问题","url":"/2021/06/24/Windows10更新问题/","content":"\nwindows10更新问题,抱歉，我们很难确定你的电脑能否运行Windows 10，请关闭安装程序，然后再试一次;\n\n<!-- more -->\n\nwindows10更新问题\n---\n\n### 问题描述：\n\n1、在设置中进行质量或其他更新，重启后在更新配置到99%是，提示无法更新，然后撤销更改；\n\n2、使用易升或更新程序（MediaCreationTool****.exe）更新，提示：“抱歉，我们很难确定你的电脑能否运行Windows 10，请关闭安装程序，然后再试一次。”；如下图。\n\n![问题截图](Windows10更新问题/问题截图.jpg)\n\n### 解决方法：\n\n（不一定能解决，只适用特定情况）\n\n1、将C盘空余出40G以上的可用空间（有时20G都不够原因是系统要保留原有系统备份、解压等）\n\n2、win+R 输入msconfig 按回车，选择引导，正常的如下图\n\n![windows10-2](Windows10更新问题/windows10-2.png)\n\n如果为空白，会报不能此电脑是否运行的系统，是因为运行msconfig，在引导页中是空白的，看不到引导的系统（但是电脑是正常可以开机的）；造成的原因可能是你最近装过双系统。\n\n3、修复引导，需要一个PE系统的U盘。（网上有很多PE的制作教程）\n\n4、进入PE系统，打开DiskGenius，如下图\n\n![windows10-3](Windows10更新问题/windows10-3.png)\n\n你的可能名字不叫ESP，可能叫分区0或其他的名称，使用DiskGenius指定盘符为x或其它可用盘符。\n\n查看你的分区类型\n\n![windows10-4](../img/picture/windows10-4.png)\n\n我的是GPT，你的可能是MBR\n\n5、打开PE系统的Windows10引导修复软件\n\na、GPT：选择 uefi  ，选择挂载地方（x盘，刚刚指定的盘符）点击修复\n\n注：以上操作仅在我自己出问题的笔记本上操作有效，注意备份数据。\n","tags":["windows10","windows10更新问题"],"categories":["windows10"]},{"title":"Java实现单链表","url":"/2021/06/23/Java实现单链表/","content":"\n单链表\n\n<!-- more -->\n\n单链表代码实现：\n---\n\n### 定义方法\n\n```java\n/**\n * @author ioutime\n * @version 1.0\n * @date 2021/6/23 21:53\n */\n\npublic class ListNode {\n    //设置头节点\n    private static ListNode head = new ListNode();\n\n    private int val;\n    private ListNode next;\n    public ListNode() { }\n    public ListNode(int val) {\n        this.val = val;\n    }\n    public ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n\n    //size\n    public int size(){\n        int len = 0;\n        ListNode temp = head;\n        while(temp!=null){\n            temp = temp.next;\n            len++;\n        }\n//        System.out.println(len);\n        return len;\n    }\n\n    //print\n    public void print(){\n        ListNode temp = head.next;\n        while(temp!=null){\n            System.out.print(temp.val+\"->\");\n            temp = temp.next;\n        }\n        System.out.println(\"null\");\n    }\n\n    //add\n    public void add(int val){\n        ListNode newNode = new ListNode(val);\n        ListNode temp = head;\n        while(temp.next!=null){\n            temp = temp.next;\n        }\n        temp.next = newNode;\n    }\n\n    //addindex\n    public void add(int index,int val){\n        if(index>size() && index <=0){\n            System.out.println(\"不合法\");\n            return;\n        }\n        ListNode newNode = new ListNode(val);\n        ListNode temp = head;\n\n        for (int i = 1; i < index; i++) {\n            temp = temp.next;\n        }\n        ListNode nextNode = temp.next;\n        temp.next = newNode;\n        newNode.next = nextNode;\n    }\n\n    //deleted\n    public void del(int index){\n        if(index>size() && index <=0){\n            System.out.println(\"不合法\");\n            return;\n        }\n        ListNode cur = head;\n        ListNode prev = null;\n        for (int i = 0; i < index; i++) {\n            prev = cur;\n            cur = cur.next;\n        }\n        if(prev==null) head.next = cur.next;\n        else {\n            prev.next = cur.next;\n        }\n\n    }\n    //select\n    public void contain(int val){\n        ListNode temp = head;\n        while (temp!=null){\n            if(temp.val == val) {\n                System.out.println(\"包含\"+val);\n                return;\n            }\n            temp = temp.next;\n        }\n        System.out.println(\"不包含\"+val);\n    }\n\n}\n```\n\n\n\n### 测试\n\n```java\n/**\n * @author ioutime\n * @version 1.0\n * @date 2021/6/23 21:54\n */\n\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head = new ListNode();\n        head.print();\n        head.add(7);\n        head.print();\n        head.add(8);\n        head.print();\n        head.add(1, 6);\n        head.print();\n        head.contain(6);\n        head.print();\n        head.del(1);\n        head.contain(6);\n        head.print();\n    }\n}\n```\n\n### 测试结果\n\n```java\nnull\n7->null\n7->8->null\n6->7->8->null\n包含6\n6->7->8->null\n不包含6\n7->8->null\n```\n\n\n\n### Java自带类实现(LinkedList)\n\n#### 代码：\n\n```java\nimport java.util.LinkedList;\n\n/**\n * @author ioutime\n * @version 1.0\n * @date 2021/6/24 14:53\n */\n\npublic class MyLinkedList {\n    public static void main(String[] args) {\n        LinkedList<Integer> linkedList = new LinkedList<>();\n        linkedList.add(23);\n        linkedList.add(45);\n        linkedList.add(56);\n        linkedList.add(1,35);\n        linkedList.remove(0);\n        for (Integer integer : linkedList) {\n            System.out.println(integer);\n        }\n    }\n}\n```\n\n\n\n#### 测试结果\n\n```java\nnull\n23->35->45->56->null\n35->45->56->null\n```\n\n","tags":["线性表","单链表"],"categories":["数据结构"]},{"title":"Java实现顺序表","url":"/2021/06/23/Java实现顺序表/","content":"\n顺序表\n\n<!-- more -->\n\n顺序表代码实现：(数组实现)\n---\n\n### 定义\n\n```java\n/**\n * @author ioutime\n * @version 1.0\n * @date 2021/6/23 17:49\n */\n\npublic class SequenceList {\n    private int[] elem;\n    private int usedSize;\n\n    public SequenceList() {\n        this.elem = new int[1];\n    }\n\n    public SequenceList(int size) {\n        this.elem = new int[size];\n    }\n\n    //扩容\n    public void addSize(){\n        this.elem = Arrays.copyOf(this.elem,this.elem.length*2);\n    }\n\n    //判断是否满了\n    public boolean isFull(){\n        if(this.elem.length==usedSize) return true;\n        return false;\n    }\n\n    //打印\n    public void printList(){\n        for (int i = 0; i < usedSize; i++) {\n            System.out.print(elem[i]+\" \");\n        }\n    }\n\n    //插入\n    public void insert(int i,int e){\n        if(isFull()){\n            addSize();\n        }\n        if(i>usedSize){\n            System.out.println(\"false\");\n        }\n        for (int j = usedSize-1; j > i-1 ; j--) {\n            elem[j+1] = elem[j];\n        }\n        elem[i] = e;\n        this.usedSize++;\n    }\n    //末尾插入\n    public void insert(int e){\n        if(isFull()){\n            addSize();\n        }\n        elem[usedSize] = e;\n        this.usedSize++;\n    }\n\n    //是否包含某个元素\n    public boolean contain(int e){\n        for (int i = 0; i < usedSize; i++) {\n            if(elem[i]==e) return true;\n        }\n        return false;\n    }\n\n    //查找某个元素对应的位置\n    public int location(int e){\n        for (int i = 0; i < usedSize; i++) {\n            if(elem[i] == e) return i;\n        }\n        return -1;\n    }\n\n    //获取 pos 位置的元素\n    public int getPosElem(int pos){\n        if(pos<0 || pos>usedSize){\n            System.out.println(\"输入位置不合法\");\n            return -1;\n        }\n        return elem[pos];\n    }\n\n    //改\n    public boolean editElem(int pos,int e){\n        if(pos<0 || pos>usedSize){\n            System.out.println(\"输入位置不合法\");\n            return false;\n        }\n        elem[pos] = e;\n        return true;\n    }\n\n    //删\n    public boolean del(int pos){\n        if(pos<0 || pos>usedSize){\n            System.out.println(\"输入位置不合法\");\n            return false;\n        }\n        for (int i = pos; i < usedSize-1; i++) {\n            elem[i] = elem[i+1];\n        }\n        usedSize--;\n        return true;\n    }\n}\n```\n\n\n\n### 测试\n\n```java\n/**\n * @author ioutime\n * @version 1.0\n * @date 2021/6/23 21:19\n */\n\npublic class Main {\n    public static void main(String[] args) {\n        SequenceList sequenceList = new SequenceList();\n        sequenceList.insert(0,2);\n        sequenceList.insert(1,4);\n        sequenceList.insert(6);\n        sequenceList.insert(7);\n        sequenceList.insert(89);\n        System.out.println(sequenceList.contain(2));\n        System.out.println(sequenceList.location(4));\n        System.out.println(sequenceList.getPosElem(3));\n        System.out.println(sequenceList.editElem(0,9));\n        System.out.println(sequenceList.getPosElem(0));\n        System.out.println(sequenceList.del(0));\n        sequenceList.printList();\n    }\n}\n```\n\n\n\n### 测试结果\n\n```java\ntrue\n1\n7\ntrue\n9\ntrue\n4 6 7 89 \n```\n\n","tags":["线性表","顺序表"],"categories":["数据结构"]},{"title":"HTML","url":"/2021/06/17/HTML/","content":"\nhtml常用标签\n\n<!-- more -->\n\n1、Html简介\n---\n\n​\tHtml 是超文本标记语言；Hyper  Text   Markup    Language\n\n​\t\t\t可以传输出图片外，还有图像、视频、音频和动画等\n\n​\tW3C 标准：\n\n​\t\tWorld  Wide  Web  Consorttium(万维网联盟)\n\n​\t\tW3C包括了\n\n​\t\t1.结构化标准语言（Html、XML）\n\n​\t\t2.表现标准语言（CSS）\n\n​\t\t3.行为标准（DOM,ECMAScript)\n\n\n\n\n\n2、基本结构\n---\n\n```html\n<!--**DOCTYPE**:告诉浏览器，我们要使用什么规范-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<!--head代表网页的头部-->\n<head>\n    <!--meta是描述性标签，用来描述网站的一些基本信息-->\n    <!--meta一般用来做SEO-->\n    <meta charset=\"UTF-8\">\n    <!--title是网站的标题-->\n    <title>Title</title>\n</head>\n<!--body代表网页的主体-->\n<body>\n    基本结构\n</body>\n</html>\n```\n\n\n\n\n\n3、基本标签\n---\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>基本标签</title>\n</head>\n<body>\n<!--标题标签:h-->\n<h1>1级标签</h1>\n<h2>2级标签</h2>\n<h3>3级标签</h3>\n<h4>4级标签</h4>\n<h5>5级标签</h5>\n<h6>6级标签</h6>\n\n<!--段落标签:p-->\n<p>기를 쓰고 사랑해야 하는 건 아냐</p>\n\n<p>하루 정도는 행복하지 않아도 괜찮아</p>\n\n<p>그럼에도 역시 완벽하군 나의 여인 um</p>\n\n<p>여전히 무수한 빈칸들이 있지</p>\n\n<!--换行标签:br-->\n기를 쓰고 사랑해야 하는 건 아냐<br>\n하루 정도는 행복하지 않아도 괜찮아<br>\n그럼에도 역시 완벽하군 나의 여인 um<br>\n여전히 무수한 빈칸들이 있지<br>\n\n<!--水平线标签:hr-->\n<hr>\n\n<!--粗体、斜体:strong ,em-->\n粗体：<strong>I love you</strong> <br>\n斜体：<em>I love you</em>\n\n<!--特殊符号-->\n空格&nbsp;&nbsp;结束 <br>\n大于：&gt; <br>\n小于：&lt; <br>\n版权符号： &copy; <br>\n\n</body>\n</html>\n```\n\n\n\n4、图像标签\n---\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>图像标签</title>\n</head>\n<body>\n<!--img标签讲解\n        **src：图片地址\n            相对地址，绝对地址\n            ../  ----上一级目录\n        **alt:当图片加载失败，会显示这个描述\n        title:当鼠标悬停在图片上显示的文字\n        width:图像宽度\n        height:图像高度\n\n-->\n\n<img src=\"../resources/image/973967.jpg\" alt=\"背景图片\" title=\"悬停文字\" width=\"400\" height=\"200\">\n\n</body>\n</html>\n```\n\n\n\n\n\n5、链接标签\n---\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>链接标签</title>\n</head>\n<body>\n<!--页面间链接-->\n<!--a标签\n    **href: 要跳转到哪个页面\n    target:表示窗口要在哪里打开\n           _blank:在新标签中打开\n           _self:在自己的网页中打开\n-->\n<a href=\"基本标签.html\" target=\"_blank\">跳转到基本标签页面，在新的窗口打开</a>\n<a href=\"https://www.baidu.com\" target=\"_self\">\n    <p>\n        <img src=\"../resources/image/973967.jpg\" alt=\"picture\" width=\"200\" height=\"200\" >\n    </p>\n\n</a>\n<hr>\n<!--锚链接\n1、需要一个锚标记\n2、跳转到标记 #\n-->\n<a id=\"top\">top</a>\n<p>\n    <img src=\"../resources/image/973967.jpg\" alt=\"picture\"  height=\"1000\" >\n</p>\n\n<a href=\"#top\">回到top</a>\n\n<hr>\n<!--功能性标签\n邮件属性：mailto\nqq链接：\n-->\n<!--邮件属性：mailto-->\n<a href=\"mailto:ioutime@163.com\">邮箱地址</a>\n<!--qq链接：-->\n<a target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3&uin=&site=qq&menu=yes\">\n    <img border=\"0\" src=\"http://wpa.qq.com/pa?p=2::51\" alt=\"联系我获取资料\" title=\"联系我获取资料\"/>\n</a>\n\n</body>\n</html>\n```\n\n\n\n6、块元素和行内元素\n\n块元素:\n\n- 无论内容多少，该元素独占一行\n- 例如（p，h1，h2，·····标签）\n\n行内元素：\n\n- 内容撑开宽度，左右都是行内元素的可以排在一行\n- 例如( a,strong,em,·····）\n\n7、列表\n---\n\n7.1、什么是列表：\n\n​\t\t列表就是信息资源的一种展示形式。它可以是信息结构化和条理化，并以列表的样式显示出来，以便浏\t\t览者能够更快捷的获取相应的信息\n\n7.2、列表的分类\n\n- 无序列表\n- 有序列表\n- 自定义列表\n\n![](/img/picture/image-20210516173504958-1621157710086.png)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>列表</title>\n</head>\n<body>\n<!--有序列表 :or（Order List）\n    应用范围：试卷，问答。······\n-->\n<ol>\n  <li>Java</li>\n  <li>Python</li>\n  <li>C/C++</li>\n</ol>\n<hr>\n<!--无序列表：ur（unorder list)\n    应用范围：导航，侧边栏····\n-->\n<ul>\n  <li>Java</li>\n  <li>Python</li>\n  <li>C/C++</li>\n</ul>\n<hr>\n<!--自定义列表：\n    dl：标签\n    dt：标签名称\n    dd：列表内容\n    应用范围：\n-->\n<dl>\n  <dt>学科</dt>\n\n  <dd>Java</dd>\n  <dd>Python</dd>\n  <dd>C/C++</dd>\n\n  <dt>成绩</dt>\n\n  <dd>98</dd>\n  <dd>89</dd>\n  <dd>90</dd>\n</dl>\n\n</body>\n</html>\n```\n\n\n\n\n\n8、表格\n---\n\n8.1、为什么使用表格\n\n​\t\t\t简单通用；结构稳定\n\n8.2、基本结构\n\n- 单元格\n- 行\n- 列\n- 跨行\n- 跨列\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>表格</title>\n</head>\n<body>\n<!--表格标签：table\n    行：tr rows\n    列：td\n    跨行：rowspan\n    跨列：colspan\n-->\n<table border=\"2px\">\n    <tr>\n        <td>1</td>\n        <td>2</td>\n        <td>3</td>\n        <td>4</td>\n    </tr>\n    <tr>\n        <td>5</td>\n        <td>6</td>\n        <td>7</td>\n        <td>8</td>\n    </tr>\n</table>\n</body>\n</html>\n```\n\n9、媒体元素\n---\n\n视频元素：\n\n​\tvideo\n\n音频元素：\n\n​\taudio\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>媒体元素</title>\n</head>\n<body>\n<!--音频和视频\n    src：资源路径\n    controls:控制条\n    autoplay:自动播放\n-->\n<audio muted src=\"../resources/audio/音频.mp3\" controls autoplay >音频</audio>\n\n<!--<video muted src=\"../resources/video/视频.mp4\" controls autoplay>视频</video>-->\n\n<video muted autoplay>\n    <source src=\"../resources/video/视频.mp4\">\n</video>\n\n</body>\n</html>\n```\n\n10、页面结构分析\n---\n\n| 元素名  |                        描述                        |\n| :-----: | :------------------------------------------------: |\n| header  |  标题头部区域的内容（用于页面和页面中的一块区域）  |\n| footer  | 标记脚部区域的内容（用于整个页面或页面的一块区域） |\n| section |              Web页面中的一块独立区域               |\n| article |                   独立的文章内容                   |\n|  aside  |                   相关内容或应用                   |\n|   nav   |                   导航类辅助内容                   |\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>网页结构分析</title>\n</head>\n<body>\n<!--header-->\n<header>\n  <p>网页头部</p>\n</header>\n<!--section-->\n<section>\n  <p>网页的主体</p>\n</section>\n<!--footer-->\n<footer>\n  <p>网页脚部</p>\n</footer>\n</body>\n</html>\n```\n\n11、iframe内联框架\n---\n\n\n\n```html\n<!DOCTYPE html><html lang=\"en\"><head>    <meta charset=\"UTF-8\">    <title>iframe</title></head><body><!--iframe:    src:地址    w-h：宽高--><iframe src=\"\" frameborder=\"0\" name=\"路飞\"></iframe><a href=\"../resources/video/海贼王混剪.mp4\"  target=\"路飞\">路飞</a></body></html>\n```\n\n\n\n12、post和get提交\n---\n\n### 12.1、表单语法\n\n```html\n<!DOCTYPE html><html lang=\"en\"><head>    <meta charset=\"UTF-8\">    <title>表单</title></head><body><h1>Login</h1><!--表单form：    **action:表单提交的位置    **method：post,get提交方式            get方式提交：我们可以在url中看到我们提交的信息，不安全，高校            post：比较安全，传输大文件--><form action=\"iframe.html\" method=\"get\">  <!--文本框-->  <p>username:<input type=\"text\" name=\"username\"></p>  <!--输入框-->  <p>password: <input type=\"password\" name=\"password\" ></p>  <!--提交和重置-->  <p>    <input type=\"submit\" name=\"登录\">    <input type=\"reset\" name=\"清除\">  </p></form></body></html>\n```\n\n### 12.2、表单元素格式\n\n| 属性      | 说明                                                         |\n| :-------- | :----------------------------------------------------------- |\n| type      | 指定元素类型(text ,password,radio,checkbox,submit,reset,file,hidden,imageh和button...)，默认为text |\n| name      | 指定表单元素的名称                                           |\n| value     | 元素的初始值，type为radio时必须指定一个值                    |\n| size      | 指定表单元素的初始宽度。当type为text或password时，表单元素的大小以字符为单位。对于其他类型，宽度是以像素为单位。 |\n| maxlength | type为text或password时，输入的最大字符数。                   |\n| checked   | type为radio或checkbox时，指定按钮是否被选中                  |\n\n### 12.3、表单元素类型\n\n1. 文本输入框\n2. 密码框\n3. 单选框\n4. 多选框\n5. 按钮\n6. 下拉框\n7. 列表框\n\n\n\n","tags":["html"],"categories":["web"]},{"title":"Java学习笔记","url":"/2021/04/24/Java学习笔记/","content":"\nJava学习笔记\n\n<!-- more -->\n\n基本概念与常识\n---\n\n### Java语言的特点\n\n- 简单易学\n\n- 面向对象（封装、多态、继承）\n\n- 分布式\n\n- 健壮性\n\n- 安全性\n\n- 可移植性(java的虚拟机)\n\n- 解释型\n\n- 高性能\n\n- 多线程\n\n- 动态性\n\n\n### JVM、JDK、JRE\n\n- JVM：Java的虚拟机，是运行Java字节码的虚拟机。JVM有针对不同操作系统的特定实现，目的是生成相同的字节码。\n\n- 字节码：JVM 可以理解的代码，也就是我们看到的 文件名.class 的文件。字节码不面向任何特定的处理器，只面向JVM。\n\n- 源码到运行的过程，如下\n\n  .java的源文件    ----JDK中的javac编译-->  .class文件    -----JVM--->  二进制机器码\n\n- JDK：全称Java Development Kit , 它是功能齐全的Java SDK （软件开发工具包）。它拥有 JRE 所拥有的一切，还有 编译器（javac） 和 工具（如：javadoc 和 jdb)。可以创建和编译程序\n\n- JRE： 全称 Java Runtime Environment，Java运行时的环境,包括了 JAM 、 Java类库 、java命令和其他的一些基础构件。但是，他不能用于创建新程序。\n\n\n总的来说，JDK > JRE > JVM\n\n\n\n### JAVA 语言“编译与解释并存”?\n\n编译型：一次性将源码翻译成机器码，然后在执行；\n\n解释型：一边编译一边运行\n\njava语言也具有编译型语言的特点，Java的源程序要先编译成字节码，然后进行解释。\n\n\n\n### Oracle JDK 和 Open JDK\n\n- Oracle JDK 不是完全开源；Open JDK 是开源的；\n\n- Oracle JDK 比 Opea JDK 更稳定\n\n- 在响应性和JVM性能方面，Oracle　JDK更好一点\n\n\n\n\n### import java 和 javax有什么区别\n\n刚开始的JavaAPI 所必需的包是Java开头的包，Javax 当时只是用来扩展API的。\n\n后来，javax 逐渐成为 Java API 的组成部分。由于移动麻烦，最终 javax 包成为标准API的一部分\n\n所以，java和javax 没什么区别。\n\n\n\n基本语法\n---\n\n\n\n### 字符型常量和字符串常量有什么区别\n\n- 形式 ：' a '      “aaaaa”\n- 含义：相当于一个整型值（ASCII 值），可以运算； 代表一个地址值\n- 内存大小：2个字节   ； 若干个字节\n\n\n\n### 注释：\n\n- 单行注释\n- 多行注释\n- 文档注释\n\n\n\n### 标识符、关键字\n\n标识符：自己取的名字\n\n关键字：Java 语言已经赋予了其特殊含义，只能用于特定的地方，特殊的标识符\n\n\n\n### Java泛型，类型擦除\n\n泛型使用方式\n\n- 泛型类\n- 泛型接口\n- 泛型方法\n\n泛型：本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。\n\nJava的泛型是伪泛型，在java编译期间，所有的泛型信息都会擦除，就是**类型擦除**\n\n\n\n### == 和 equals 的区别\n\n- ==是对基本数据类型是值比较， 对引用数据类型，比较的是对象的内存地址。\n- equals() 只能用于判断对象是否相等\n\nequals()方法的使用存在两种情况\n\n- 类没有重写equals()方法：等价于使用 \"==\" 比较两个对象\n- 类重写了equals() 方法：\n\n\n\n### hashCode() 与 equals()\n\n- hashCode()：作用是获取哈希码，也称散列码。它实际上返回一个**int**整数\n  - 哈希码作用：确定该对象在哈希表中的索引位置\n  - hashCode()：可以减少equals的使用次数，提高执行速度\n\n- 重写equals 时要重写 hashCode 方法\n\n     **两个相等的对象必须具有相等的散列码（Java关键约定）**\n\n  \n\n  ​\t\t\n\n\n\n基本数据类型\n---\n\n\n\n### 基本数据类型、包装类型、字节\n\n| 基本数据类型 | 字节 | 包装类型（引用类型） |\n| :-:| :--: | :--: |\n| int | 4 | Integer |\n| long | 8 | Long |\n| short | 2 | Short |\n| byte | 1 | Byte |\n| char | 2 | Character |\n| float | 4 | Float |\n| double | 8 | Double |\n| boolean | - | Boolean |\n\n\n\n### 自动装箱、拆箱\n\n- 装箱：将基本类型自动转化为对应的引用类型\n\n- 拆箱：将包装类型转换位基本类型\n\n  \n\n```java\n装箱:Integer i = 9;   ===== Integer i = Integer.valueOf(9);\n拆箱:int n = i;       ===== int n = i.intValue();\n```\n\n**注：包装类型比较是否相等，要哟equals()方法**\n\n\n\n\n\n高频面试题\n---\n\n\n\n### String 、StringBuilder、StringBuffer\n\n- String：String的值被创建后不能修改，任何修改都会引发新的String对象的生成\n- StringBuffer：和String 类似，但是值是可以被修改的，使用 synchronized来保证线程安全\n- StringBuilder：非线程安全\n\n\n\n### 反射\n\n反射指的在运行状态中， 对于任意一个类都能知道这个类所有的属性和方法；平且对于任意一个对象，都能调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为反射机制。\n\n\n\n### 深拷贝、浅拷贝\n\n数据分为基本数据类型和引用数据类型。\n\n基本数据类型：数据是直接存放在栈中的\n\n引用数据类型：存放在栈中的是对象的引用地址，真实的对象存放在堆内存中\n\n浅拷贝：对于基本数据类型，直接复制其数据；对于引用数据类型，拷贝的是其对象的引用地址，新旧对象指向的相同的内存地址，无论修改哪个，另一个一会改变\n\n深拷贝：对于基本数据类型，直接复制其数据；对于引用数据类型，深拷贝是在内存中开辟新的空间，在新的内存空间中复制一个一模一样的对象，新老对象不共享内存，修改一个不会修改另一个。\n\n\n\n### 并发、并行\n\n并发：两个或两个以上事件在同一时间间隔内发生。\n\n并行：两个或两个以上事件在同一时刻发生\n\n\n\n### 构造器不可以被重写\n\nConstructor 不能被重写（Override) ，但是可以被 重载（overload）\n\n\n\n### Java只有值传递，对于对象参数，值得内容是对象的引用。\n\n\n\n### 静态变量 和 成员变量\n\n- 静态变量存放在方法区中；成员变量存放在堆内存中\n\n- 静态变量与 类 共存亡；成员变量与 对象 共存亡\n\n- 静态变量属于类；成员变量属于对象\n\n- 静态变量可以被对象调用，也可以被类名调用；成员变量只能被对象调用。\n\n  \n\n### 静态方法内部 能否发出对 非静态方法的调用\n\n- 如何没用显示创建对象的实例，则不可以调用。\n- 显示的创建对象实例，可以调用。\n\n### 重载和重写\n\n方法的重载和重写都是实现多态的方式，重载是编译时的多态性，重写时运行时的多态性。\n\n- 重载：overload，一个类中有多个相同名字的方法，但是具有不同的参数列表（参数类型不同、参数个数不同或两者都不一样）\n- 重写：override，发生在父类和子类之间，子类对父类的方法进行重写，参数不能改变，返回值可以修改，但必须时父类返回值的派生类。\n\n### abstract class (抽象类) 和 interface (接口) \n\n- 抽象类只能单继承；接口可以多实现\n\n- 抽象类可以有构造方法；接口不能有\n\n- 抽象类中可以有成员变量；接口中没有，只能时常量（默认 public static final)\n\n- 抽象类中可以包含非抽象方法；在java 7 之前 接口中所有方法都是抽象的，在Java 8之后\n\n  接口支持非抽象方法：default 方法、静态方法等。Java 9 支持稀有方法，稀有静态方法\n\n- 抽象类中的抽象方法可以是任意修饰符；Java 8之前接口方法只有public类型，在Java9之后支持private\n- 接口时自上而下的，接口规范了某些行为，是对一行为的抽象；抽象类是自下而上的抽象过程，抽象类提供了通用实现，是对某一类事物的抽象。\n\n\n\n### Error  和  Exception 的区别\n\n- Error  和  Exception 都是 Throwable  的子类，用于表示程序不正常情况\n- Error 表示系统级的错误和程序不必处理的异常。\n- Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计和实现的问题。\n\n\n\n### final关键字\n\n- 修饰类：该类不能派生出新的子类，不能作为父类被继承；一个类不能同时被声明为abstract 和 final\n- 修饰方法：该方法的子类不能被重写\n- 修饰变量：该变量必须在声明时给定初始值，不能再被修改，只能被读取；如果该变量是对象，则指的是引用不可改变，但是对象的属性还是可以修改的。\n\n\n\n### finally、finalize\n\n- finally：是对java异常处理机制的最佳补充，通常配合try 、catch使用。通常用于释放锁、数据库连接等资源。\n- finalize：是Object 中的方法，在垃圾收集器将对象从内存中清除出去之前必须要的清理工作。finalize()方法在java 9 之后被弃用。\n\n\n\n### try、catch、finally\n\n在return 之前，会保存要返回的值，然后执行 finally中的语句（如果finally中有retrun 则结束，不会再回到之前的return中。）\n\n\n\n### Java 1.8 之后的特性\n\n接口默认方法：Java 8 之后允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字\n\nLambda 表达式和函数式接口：本质是一段匿名内部类，也可以是一段可以传递的代码\n\nStream API ：\n\n方法引用：\n\n日期时间API：\n\nOptional 类：\n\n新工具：新的编译工具\n\n\n\n### wait() 和 sleep() 方法\n\n- wait() 来自 Object 类；sleep() 来自 Thread 类\n- wait() 会释放同步锁，让其它线程进入synchronized代码块执行；sleep() 不会释放同步锁\n- wait() 只能在同步控制方法或块中里面才能使用，否则会报错IllegalArgumentException\n- wait()需要其他线程掉用同一对象的notify()/notifyAll() 才能恢复；sleep()在时间到了之后会自动恢复\n\n\n\n### 线程的sleep()方法和yield()方法\n\n线程执行sleep() 方法之后进入超时等待（TIMED_WAITING）状态；执行yield() 方法进入就绪等待\n\n- sleep() 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程运行的机会\n- yield()方法只会给相同优先级或更高的优先级的线程以运行的机会\n\n\n\n### 线程的 join() 方法\n\n用于等待当前线程终止。\n\n\n\n### 多线程程序的实现\n\n- 继承Thread 类，重写run() 方法，无返回值void\n- 实现Runnable 接口，重写 run() 方法，无返回值void\n- 实现Callable 接口\n\n\n\n### Thread 调用 start() 方法和 run() 方法\n\nrun() ：普通方法的调用，在主线程中执行，不会创建一个线程来执行\n\nstart()：启动一个新的线程，这是这个线程处于就绪态，一但的到cpu的时间片，就开始执行run()方法\n\n\n\n### 线程的状态\n\n![view](Java学习笔记/view.jpg)\n\n- 初始（NEW)：新建但是没有调用start()方法\n\n- 运行（RUNNABLE)：包含就绪（READY）和 运行中（RUNNING）\n\n  - 就绪（READY)：调用start() 方法，等待获取时间片\n\n  - 运行中（RUNNING)：获取到时间片\n\n    就绪  <------系统调度（yield）-----> 运行中\n\n- 阻塞（BLOCKED）：\n\n- 等待（WAITING)：\n- 超时等待（TIMED_WAITING）：\n- 终止（TERMINATED）：\n\n​\t\n\n### synchronized 和 Lock 的区别\n\n- Lock是一个接口；synchronized是Java中的关键字\n- Lock在发生异常，如果没有主动通过unLock() 去释放锁，会造成死锁；synchronized则不会；\n- Lock的使用更加灵活，有响应中断、超时时间；\n\n\n\n### 死锁\n\n- 互斥条件：一段时间内某资源只能被一个线程占用\n- 请求和保持条件：进程已经获得一个资源，但又对另一个资源发出请求，而该资源被另一个进程占用\n- 不可抢占条件：不可强制剥夺\n- 环路等待条件\n\n\n\n### 线程池\n\n常用线程池（线程池是一个典型的“用空间换时间”的应用案例）\n\n- FixedThreadPool:线程数固定的线程池\n- SingleThreadExecutor：线程数量为1的线程池\n- CachedThreadPool：缓存线程池\n\n使用：ExecutorService是所有的线程池都实现了的接口，用这个接口可以定义句柄\n\n​\t\t   Executors类用于创建不同种类的线程池\n\n```java\n//定义一个有5个线程的线程池\nExecutorService fixedTP = Executors.newFixedThreadPool(5); \nExecutorService singleTE = Executors.newSingleThreadExecutor();\nExecutorService cachedTP = Executors.newCachedThreadPool();\n```\n\n优点：\n\n- 降低资源消耗\n- 提高响应速度\n- 增加线程的可管理性\n\n核心属性：\n\n- threadFactory(线程工厂)：\n- corePoolSize(核心线程数)：\n- workQueue（队列）：\n- handler（ 拒绝策略）：\n- keepAliveTime（保持存活时间）：\n\n拒绝策略\n\n- AbortPolicy：中止策略，默认的，使用该策略会抛出异常，阻止系统继续运行\n- DiscardPolicy：抛弃策略，什么都不做，直接抛弃拒绝的任务\n- DiscardOldestPolicy：抛弃最老策略，抛弃阻塞队列中最老的任务\n- CallerRunsPolicy：调用者运行策略，\n\n工作流程：\n\n1. 调用Excutors类的静态方法newCachedThreadPool 或 newFixedThreadPool\n2. 调用submit 提交 Runnable 或 Callable 对象\n3. 保存好返回的Future 对象，以便得到结果或取消任务\n4. 但不想再提交任何任务时，调用shutdown\n","tags":["Java"],"categories":["Java"]}]